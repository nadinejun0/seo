This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
classify.html
CLAUDE.md
index.html
package.json
README.md
server.js
test-server.js
test.html

================================================================
Files
================================================================

================
File: classify.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Classifier - OpenAI API</title>
    <style>
        :root {
            --primary: #5436DA;
            --primary-hover: #4A2FB8;
            --light-purple: #F3F0FF;
            --gray-light: #f5f5f5;
            --gray-med: #e0e0e0;
            --gray-dark: #767676;
            --success-green: #4CAF50;
            --warning-orange: #FFC107;
        }
        
        * {
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 0;
            background-color: #f7f7f7;
            color: #222;
            line-height: 1.4;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: white;
            border-bottom: 1px solid var(--gray-med);
            padding: 15px 0;
        }
        
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
            text-decoration: none;
            margin-left: 20px;
        }
        
        main {
            display: flex;
            flex-wrap: wrap;
            margin-top: 30px;
            gap: 20px;
        }
        
        .input-section {
            flex: 1 1 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
            position: relative;
        }
        
        .results-section {
            flex: 1 1 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }
        
        h1, h2, h3 {
            margin-top: 0;
            color: #222;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        textarea, input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--gray-med);
            border-radius: 6px;
            font-size: 16px;
            margin-bottom: 15px;
        }
        
        textarea {
            min-height: 150px;
            resize: vertical;
        }
        
        .button {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 24px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .button:hover {
            background-color: var(--primary-hover);
        }
        
        .api-key-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--gray-med);
        }
        
        .classification-option {
            margin-bottom: 10px;
        }
        
        .results-display {
            margin-top: 20px;
        }
        
        .loading {
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--gray-med);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
        
        .result-card {
            background-color: var(--light-purple);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .result-label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .result-content {
            white-space: pre-wrap;
        }
        
        .cat-label {
            display: inline-block;
            background-color: var(--primary);
            color: white;
            padding: 4px 8px;
            margin: 4px;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .confidence {
            margin-left: 8px;
            font-size: 14px;
            color: var(--gray-dark);
        }
        
        .category-list {
            margin-top: 10px;
        }

        .error-message {
            color: red;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .feedback-message {
            background-color: #E3F2FD;
            color: #0D47A1;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 5px;
            margin-bottom: 10px;
            border-left: 4px solid #2196F3;
        }
        
        .feedback-success {
            background-color: #E8F5E9;
            border-left: 4px solid #4CAF50;
            color: #1B5E20;
        }
    </style>
</head>
<body>
    <header>
        <a href="#" class="logo">OpenAI Text Classifier</a>
    </header>
    
    <div class="container">
        <main>
            <section class="input-section">
                <h1>Classify Text with OpenAI API</h1>
                <p>Enter text to classify into predefined categories or add your own classification scheme.</p>
                
                <div class="api-key-section">
                    <label for="api-key">OpenAI API Key:</label>
                    <input type="text" id="api-key" placeholder="Enter your OpenAI API Key">
                    <p>Your API key is stored only in your browser and is never sent to our servers.</p>
                </div>
                
                <div>
                    <label for="text-input">Text to Classify:</label>
                    <textarea id="text-input" placeholder="Enter text to classify..."></textarea>
                    <div class="feedback-message hidden" id="text-feedback"></div>
                </div>
                
                <div>
                    <label>Classification Type:</label>
                    <div class="classification-option">
                        <input type="radio" id="predefined" name="class-type" checked>
                        <label for="predefined">Predefined Categories</label>
                        <select id="predefined-select">
                            <option value="sentiment">Sentiment (Positive, Negative, Neutral)</option>
                            <option value="content">Content Type (News, Opinion, Tutorial, Review)</option>
                            <option value="topic">Topic (Technology, Business, Politics, Entertainment)</option>
                            <option value="intent">User Intent (Question, Complaint, Suggestion, Praise)</option>
                        </select>
                    </div>
                    
                    <div class="classification-option">
                        <input type="radio" id="custom" name="class-type">
                        <label for="custom">Custom Categories</label>
                        <input type="text" id="custom-categories" placeholder="Enter categories separated by commas (e.g., Red, Blue, Green)" disabled>
                        <div class="feedback-message hidden" id="categories-feedback"></div>
                    </div>
                </div>
                
                <div class="error-message hidden" id="error-display"></div>
                
                <button id="classify-btn" class="button">Classify Text</button>
                <button id="classify-text-btn" class="button">Classify Text Only</button>
                <button id="classify-categories-btn" class="button">Validate Categories</button>
                
                <div class="loading" id="loading">
                    <div class="loading-spinner"></div>
                    <span style="margin-left: 10px;">Processing...</span>
                </div>
            </section>
            
            <section class="results-section hidden" id="results">
                <h2>Classification Results</h2>
                
                <div class="result-card">
                    <div class="result-label">Primary Classification:</div>
                    <div class="result-content" id="primary-result"></div>
                </div>
                
                <div class="result-card">
                    <div class="result-label">Classification Breakdown:</div>
                    <div class="category-list" id="category-breakdown"></div>
                </div>
                
                <div class="result-card">
                    <div class="result-label">Model Explanation:</div>
                    <div class="result-content" id="explanation"></div>
                </div>
            </section>
        </main>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Get DOM elements
            const apiKeyInput = document.getElementById('api-key');
            const textInput = document.getElementById('text-input');
            const predefinedRadio = document.getElementById('predefined');
            const customRadio = document.getElementById('custom');
            const predefinedSelect = document.getElementById('predefined-select');
            const customCategories = document.getElementById('custom-categories');
            const classifyBtn = document.getElementById('classify-btn');
            const classifyTextBtn = document.getElementById('classify-text-btn');
            const classifyCategoriesBtn = document.getElementById('classify-categories-btn');
            const loadingElement = document.getElementById('loading');
            const resultsSection = document.getElementById('results');
            const primaryResult = document.getElementById('primary-result');
            const categoryBreakdown = document.getElementById('category-breakdown');
            const explanation = document.getElementById('explanation');
            const errorDisplay = document.getElementById('error-display');
            const textFeedback = document.getElementById('text-feedback');
            const categoriesFeedback = document.getElementById('categories-feedback');
            
            // Enable/disable custom categories input based on radio selection
            predefinedRadio.addEventListener('change', function() {
                if (this.checked) {
                    customCategories.disabled = true;
                    predefinedSelect.disabled = false;
                }
            });
            
            customRadio.addEventListener('change', function() {
                if (this.checked) {
                    customCategories.disabled = false;
                    predefinedSelect.disabled = true;
                }
            });
            
            // Check if API key exists in localStorage
            if (localStorage.getItem('openai_api_key')) {
                apiKeyInput.value = localStorage.getItem('openai_api_key');
            }
            
            // Function to show field feedback
            function showFeedback(element, message, isSuccess = false) {
                element.textContent = message;
                element.classList.remove('hidden');
                
                if (isSuccess) {
                    element.classList.add('feedback-success');
                } else {
                    element.classList.remove('feedback-success');
                }
            }
            
            // Handle classify text only button click
            classifyTextBtn.addEventListener('click', async function() {
                // Clear previous feedback
                textFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Validate inputs
                const apiKey = apiKeyInput.value.trim();
                const text = textInput.value.trim();
                
                if (!apiKey) {
                    showError('Please enter your OpenAI API key');
                    return;
                }
                
                if (!text) {
                    showError('Please enter text to classify');
                    return;
                }
                
                // Save API key to localStorage
                localStorage.setItem('openai_api_key', apiKey);
                
                // Show loading indicator
                loadingElement.style.display = 'flex';
                
                try {
                    // Call API to validate text only
                    const systemPrompt = `
                        You are a text analysis assistant. Your task is to analyze the provided text and provide feedback.
                        Your response should be brief and constructive, focusing on how to improve the text for classification.
                    `;
                    
                    const userPrompt = `Please analyze the following text and provide feedback on its clarity and structure: "${text}"`;
                    
                    const result = await callOpenAI(apiKey, systemPrompt, userPrompt, 'text');
                    
                    // Display feedback
                    showFeedback(textFeedback, result.content[0].text);
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Hide loading indicator
                    loadingElement.style.display = 'none';
                }
            });
            
            // Handle validate categories button click
            classifyCategoriesBtn.addEventListener('click', async function() {
                // Clear previous feedback
                categoriesFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Validate inputs
                const apiKey = apiKeyInput.value.trim();
                
                if (!apiKey) {
                    showError('Please enter your OpenAI API key');
                    return;
                }
                
                // Get classification categories
                let categories;
                if (predefinedRadio.checked) {
                    const selectedOption = predefinedSelect.value;
                    switch (selectedOption) {
                        case 'sentiment':
                            categories = ['Positive', 'Negative', 'Neutral'];
                            break;
                        case 'content':
                            categories = ['News', 'Opinion', 'Tutorial', 'Review'];
                            break;
                        case 'topic':
                            categories = ['Technology', 'Business', 'Politics', 'Entertainment'];
                            break;
                        case 'intent':
                            categories = ['Question', 'Complaint', 'Suggestion', 'Praise'];
                            break;
                    }
                } else {
                    // Parse custom categories
                    categories = customCategories.value.split(',').map(cat => cat.trim()).filter(cat => cat);
                    if (categories.length < 2) {
                        showError('Please enter at least two categories separated by commas');
                        return;
                    }
                }
                
                // Save API key to localStorage
                localStorage.setItem('openai_api_key', apiKey);
                
                // Show loading indicator
                loadingElement.style.display = 'flex';
                
                try {
                    // Call API to validate categories
                    const systemPrompt = `
                        You are a classification expert. Your task is to analyze the provided categories and provide feedback.
                        Your response should be brief and constructive, focusing on whether the categories are well-defined,
                        mutually exclusive, and collectively exhaustive.
                    `;
                    
                    const userPrompt = `Please analyze the following classification categories and provide feedback: ${categories.join(', ')}`;
                    
                    const result = await callOpenAI(apiKey, systemPrompt, userPrompt, 'categories');
                    
                    // Display feedback
                    showFeedback(categoriesFeedback, result.content[0].text, true);
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Hide loading indicator
                    loadingElement.style.display = 'none';
                }
            });
            
            // Handle full classify button click
            classifyBtn.addEventListener('click', async function() {
                // Clear previous results and errors
                errorDisplay.classList.add('hidden');
                errorDisplay.textContent = '';
                textFeedback.classList.add('hidden');
                categoriesFeedback.classList.add('hidden');
                
                // Validate inputs
                const apiKey = apiKeyInput.value.trim();
                const text = textInput.value.trim();
                
                if (!apiKey) {
                    showError('Please enter your OpenAI API key');
                    return;
                }
                
                if (!text) {
                    showError('Please enter text to classify');
                    return;
                }
                
                // Save API key to localStorage
                localStorage.setItem('openai_api_key', apiKey);
                
                // Get classification categories
                let categories;
                if (predefinedRadio.checked) {
                    const selectedOption = predefinedSelect.value;
                    switch (selectedOption) {
                        case 'sentiment':
                            categories = ['Positive', 'Negative', 'Neutral'];
                            break;
                        case 'content':
                            categories = ['News', 'Opinion', 'Tutorial', 'Review'];
                            break;
                        case 'topic':
                            categories = ['Technology', 'Business', 'Politics', 'Entertainment'];
                            break;
                        case 'intent':
                            categories = ['Question', 'Complaint', 'Suggestion', 'Praise'];
                            break;
                    }
                } else {
                    // Parse custom categories
                    categories = customCategories.value.split(',').map(cat => cat.trim()).filter(cat => cat);
                    if (categories.length < 2) {
                        showError('Please enter at least two categories separated by commas');
                        return;
                    }
                }
                
                // Show loading indicator
                loadingElement.style.display = 'flex';
                
                try {
                    // Call OpenAI API for classification
                    const result = await classifyWithOpenAI(apiKey, text, categories);
                    
                    // Process and display results
                    displayResults(result, categories);
                    
                    // Show results section
                    resultsSection.classList.remove('hidden');
                    
                    // Show success feedback
                    showFeedback(textFeedback, "Text successfully classified!", true);
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Hide loading indicator
                    loadingElement.style.display = 'none';
                }
            });
            
            // Function to call OpenAI API
            async function callOpenAI(apiKey, systemPrompt, userPrompt, field = 'all') {
                try {
                    console.log('Sending request to proxy server...');
                    const response = await fetch('/api/classify', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            apiKey,
                            systemPrompt,
                            userPrompt,
                            field
                        })
                    });
                    
                    console.log('Response status:', response.status);
                    
                    if (!response.ok) {
                        let errorMessage = 'API request failed with status ' + response.status;
                        try {
                            const errorData = await response.json();
                            errorMessage = errorData.error || errorMessage;
                        } catch (e) {
                            // If we can't parse the error as JSON, just use the status code message
                        }
                        throw new Error(errorMessage);
                    }
                    
                    const data = await response.json();
                    return data;
                } catch (fetchError) {
                    console.error('Fetch error:', fetchError);
                    if (fetchError.message.includes('NetworkError') || fetchError.message.includes('Failed to fetch')) {
                        throw new Error('Network error: Make sure the server is running (npm start)');
                    }
                    throw fetchError;
                }
            }
            
            // Function to call OpenAI API for classification
            async function classifyWithOpenAI(apiKey, text, categories) {
                // Create the system prompt for classification
                const systemPrompt = `
                    You are a text classification assistant. Your task is to classify the provided text into one of the following categories:
                    ${categories.join(', ')}
                    
                    Your response should be in JSON format with the following structure:
                    {
                        "primary_category": "The single best category for this text",
                        "confidence": "A confidence score from 0.0 to 1.0",
                        "category_scores": {
                            "Category1": 0.X,
                            "Category2": 0.Y,
                            ...
                        },
                        "explanation": "A brief explanation of why you chose this classification"
                    }
                `;
                
                const userPrompt = `Please classify the following text: "${text}"`;
                
                const data = await callOpenAI(apiKey, systemPrompt, userPrompt, 'full');
                
                // Parse the JSON response from the model
                try {
                    const contentText = data.content[0].text;
                    // Extract JSON from the response
                    const jsonMatch = contentText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        return JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('Could not parse classification result');
                    }
                } catch (error) {
                    throw new Error('Invalid response from OpenAI API: ' + error.message);
                }
            }
            
            // Function to display classification results
            function displayResults(result, categories) {
                // Display primary result
                primaryResult.textContent = `${result.primary_category} (${Math.round(result.confidence * 100)}% confidence)`;
                
                // Display category breakdown
                categoryBreakdown.innerHTML = '';
                for (const category of categories) {
                    const score = result.category_scores[category] || 0;
                    const catElement = document.createElement('div');
                    catElement.innerHTML = `
                        <span class="cat-label">${category}</span>
                        <span class="confidence">${Math.round(score * 100)}%</span>
                    `;
                    categoryBreakdown.appendChild(catElement);
                }
                
                // Display explanation
                explanation.textContent = result.explanation;
            }
            
            // Function to show error messages
            function showError(message) {
                errorDisplay.textContent = message;
                errorDisplay.classList.remove('hidden');
            }
        });
    </script>
</body>
</html>

================
File: CLAUDE.md
================
# CLAUDE.md - SEO Tool Project Guide

## Commands
- Start server: `npm start` (runs `node server.js` on port 3000)
- Test server: `node test-server.js` (runs on port 3001)
- Access applications:
  - Etsy Listing Optimizer: http://localhost:3000/index.html
  - Text Classifier: http://localhost:3000/classify.html
  - API Test: http://localhost:3000/test.html

## Code Style Guidelines
- **Imports**: CommonJS style (require/module.exports)
- **Error Handling**: Use try/catch blocks with specific error messages
- **Logging**: Use console.log with timestamps and request details
- **API Calls**: Use fetch with proper error handling
- **Frontend**: JavaScript with event listeners, no frameworks
- **HTML/CSS**: Clean, semantic markup with CSS variables
- **Naming**: camelCase for variables/functions, descriptive names
- **Comments**: Use comments for function descriptions and complex logic

## Project Structure
- Server-side proxy for API calls (server.js)
- Static HTML/CSS/JS frontend
- OpenAI API integration for text classification

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Etsy Listing Optimizer</title>
    <style>
        :root {
            --etsy-orange: #F56400;
            --etsy-hover: #E55400;
            --etsy-light: #FFF3ED;
            --gray-light: #f5f5f5;
            --gray-med: #e0e0e0;
            --gray-dark: #767676;
            --success-green: #4CAF50;
            --warning-orange: #FFC107;
        }
        
        * {
            box-sizing: border-box;
            font-family: 'Graphik Webfont', -apple-system, 'Helvetica Neue', 'Droid Sans', Arial, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 0;
            background-color: #f7f7f7;
            color: #222;
            line-height: 1.4;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: white;
            border-bottom: 1px solid var(--gray-med);
            padding: 15px 0;
        }
        
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--etsy-orange);
            text-decoration: none;
            margin-left: 20px;
        }
        
        main {
            display: flex;
            flex-wrap: wrap;
            margin-top: 30px;
            gap: 20px;
        }
        
        .input-section {
            flex: 1 1 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .results-section {
            flex: 1 1 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .score-cards {
            flex: 1 1 300px;
        }
        
        .improvements {
            flex: 2 1 600px;
        }
        
        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }
        
        h1, h2, h3 {
            margin-top: 0;
            color: #222;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        textarea, input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--gray-med);
            border-radius: 6px;
            font-size: 16px;
            margin-bottom: 15px;
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        
        .tags-input {
            display: flex;
            flex-wrap: wrap;
            border: 1px solid var(--gray-med);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 15px;
            min-height: 48px;
        }
        
        .tag {
            display: inline-flex;
            align-items: center;
            background: var(--etsy-light);
            color: var(--etsy-orange);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 4px;
            font-size: 14px;
        }
        
        .tag-delete {
            margin-left: 6px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .tags-input input {
            flex: 1;
            border: none;
            outline: none;
            padding: 8px;
            font-size: 14px;
            min-width: 120px;
        }
        
        .button {
            background-color: var(--etsy-orange);
            color: white;
            border: none;
            border-radius: 24px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .button:hover {
            background-color: var(--etsy-hover);
        }
        
        .score {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 6px;
            background-color: var(--gray-light);
        }
        
        .score-label {
            font-weight: 500;
        }
        
        .score-value {
            font-size: 18px;
            font-weight: bold;
        }
        
        .score-card {
            margin-bottom: 10px;
        }
        
        .score-details {
            margin-top: 5px;
            font-size: 14px;
            color: var(--gray-dark);
        }
        
        .grade-a {
            background-color: #DCEDC8;
        }
        
        .grade-b {
            background-color: #FFF9C4;
        }
        
        .grade-c {
            background-color: #FFE0B2;
        }
        
        .grade-d {
            background-color: #FFCCBC;
        }
        
        .compare-fields {
            display: flex;
            margin-bottom: 20px;
            gap: 20px;
        }
        
        .field-column {
            flex: 1;
        }
        
        .field-label {
            font-weight: 500;
            margin-bottom: 5px;
            display: block;
        }
        
        .field-content {
            padding: 15px;
            background: var(--gray-light);
            border-radius: 6px;
            min-height: 100px;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        
        .use-improved {
            font-size: 14px;
            color: var(--etsy-orange);
            text-decoration: underline;
            cursor: pointer;
            display: inline-block;
            margin-bottom: 15px;
        }
        
        .improvement-note {
            color: var(--gray-dark);
            font-size: 14px;
            font-style: italic;
            margin-bottom: 10px;
        }
        
        .tag-count {
            color: var(--gray-dark);
            font-size: 14px;
            margin-top: 5px;
        }
        
        .loading {
            display: none;
            align-items: center;
            justify-content: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--gray-med);
            border-top: 4px solid var(--etsy-orange);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
        
        .help-tip {
            font-size: 14px;
            color: var(--gray-dark);
            margin-bottom: 10px;
        }
        
        .error-message {
            color: #F44336;
            font-weight: bold;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
            background-color: #FFEBEE;
        }
        
        .feedback-message {
            background-color: #FFF3ED;
            color: #E55400;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 5px;
            margin-bottom: 10px;
            border-left: 4px solid #F56400;
        }
        
        .feedback-success {
            background-color: #E8F5E9;
            border-left: 4px solid #4CAF50;
            color: #1B5E20;
        }
        
        .secondary-button {
            background-color: #FFFFFF;
            color: var(--etsy-orange);
            border: 1px solid var(--etsy-orange);
            border-radius: 24px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-right: 10px;
            margin-top: 5px;
        }
        
        .secondary-button:hover {
            background-color: var(--etsy-light);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--gray-med);
        }
        
        .tab {
            padding: 12px 24px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
        }
        
        .tab.active {
            border-bottom-color: var(--etsy-orange);
            color: var(--etsy-orange);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @media (max-width: 768px) {
            .compare-fields {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header>
        <a href="#" class="logo">Etsy Listing Optimizer</a>
    </header>
    
    <div class="container">
        <main>
            <section class="input-section">
                <h1>Optimize Your Etsy Listing</h1>
                <p>Enter your listing details below to receive personalized optimization suggestions based on Etsy's search algorithm.</p>
                
                <div class="tabs">
                    <div class="tab active" data-tab="single">Single Listing</div>
                    <div class="tab" data-tab="batch">Batch Optimizer</div>
                </div>
                
                <div class="tab-content active" id="single-tab">
                    <form id="optimizer-form">
                        <div class="api-key-section">
                            <label for="api-key">OpenAI API Key:</label>
                            <input type="text" id="api-key" placeholder="Enter your OpenAI API Key">
                            <p>Your API key is stored only in your browser and is never sent to our servers.</p>
                        </div>
                        
                        <div>
                            <label for="title">Product Title:</label>
                            <textarea id="title" placeholder="Enter your product title here...">Vintage Persian Runner Boho Pink Rug Handmade, Geometric Tribal Oriental Turkish Carpet, Bohemian Wool Hallway Entry Decor Small Area Mat</textarea>
                            <div class="help-tip">Character count: <span id="title-count">0</span>/140 (100-140 characters recommended)</div>
                            <div class="feedback-message hidden" id="title-feedback"></div>
                            <button type="button" id="title-only-btn" class="secondary-button">Optimize Title Only</button>
                        </div>
                        
                        <div>
                            <label for="tags">Tags (max 13):</label>
                            <div class="tags-input" id="tags-container">
                                <input type="text" id="tag-input" placeholder="Type a tag and press Enter...">
                            </div>
                            <div class="tag-count"><span id="tag-count">0</span>/13 tags used</div>
                            <div class="feedback-message hidden" id="tags-feedback"></div>
                            <button type="button" id="tags-only-btn" class="secondary-button">Optimize Tags Only</button>
                        </div>
                        
                        <div>
                            <label for="description">Product Description:</label>
                            <textarea id="description" placeholder="Enter your product description here..."></textarea>
                            <div class="feedback-message hidden" id="description-feedback"></div>
                            <button type="button" id="description-only-btn" class="secondary-button">Optimize Description Only</button>
                        </div>
                        
                        <div class="error-message hidden" id="error-display"></div>
                        
                        <button type="submit" class="button">Analyze & Optimize All</button>
                    </form>
                </div>
                
                <div class="tab-content" id="batch-tab">
                    <p>Upload a CSV file with multiple listings to analyze and optimize in bulk.</p>
                    <input type="file" id="batch-file" accept=".csv">
                    <div class="help-tip">CSV should have columns for: title, tags, description</div>
                    <button class="button" id="batch-analyze">Upload & Analyze</button>
                </div>
            </section>
            
            <section class="results-section hidden" id="results">
                <div class="loading">
                    <div class="loading-spinner"></div>
                </div>
                
                <div class="score-cards">
                    <div class="card">
                        <h2>Listing Scores</h2>
                        
                        <div class="score grade-b">
                            <div class="score-label">Overall Grade</div>
                            <div class="score-value">3.0/4.0</div>
                        </div>
                        
                        <div class="score-card">
                            <div class="score-label">Title Score</div>
                            <div class="score-value">2.8/4.0</div>
                            <div class="score-details">
                                <div>✓ Character Count: 1.2/1.2</div>
                                <div>✗ Focus Keywords: 0/1.2</div>
                                <div>✓ Keyword Stuffing: 0.8/0.8</div>
                                <div>✓ Structure: 0.8/0.8</div>
                            </div>
                        </div>
                        
                        <div class="score-card">
                            <div class="score-label">Tags Score</div>
                            <div class="score-value">3.0/4.0</div>
                            <div class="score-details">
                                <div>✓ Tag Count: 1.0/1.0</div>
                                <div>✓ Multi-word Tags: 1.0/1.0</div>
                                <div>✗ Chain Structure: 0.5/1.0</div>
                                <div>✓ Diversity: 0.5/1.0</div>
                            </div>
                        </div>
                        
                        <div class="score-card">
                            <div class="score-label">Description Score</div>
                            <div class="score-value">3.2/4.0</div>
                            <div class="score-details">
                                <div>✓ Length: 1.2/1.2</div>
                                <div>✓ Formatting: 0.8/0.8</div>
                                <div>✓ Keyword Integration: 1.2/1.6</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="improvements">
                    <div class="card">
                        <h2>Optimization Suggestions</h2>
                        
                        <h3>Title</h3>
                        <div class="compare-fields">
                            <div class="field-column">
                                <span class="field-label">Original Title</span>
                                <div class="field-content" id="original-title">Vintage Persian Runner Boho Pink Rug Handmade, Geometric Tribal Oriental Turkish Carpet, Bohemian Wool Hallway Entry Decor Small Area Mat</div>
                            </div>
                            <div class="field-column">
                                <span class="field-label">Improved Title</span>
                                <div class="field-content" id="improved-title">Vintage Persian Runner Boho Pink Rug Handmade | Geometric Tribal Oriental Turkish Carpet | Bohemian Wool Hallway Entry Decor Small Area Mat</div>
                                <a class="use-improved" id="use-title">Use this improved title</a>
                            </div>
                        </div>
                        <div class="improvement-note">Changed commas to pipes (|) for better visual separation and improved readability.</div>
                        
                        <h3>Tags</h3>
                        <div class="compare-fields">
                            <div class="field-column">
                                <span class="field-label">Original Tags</span>
                                <div class="field-content" id="original-tags">No tags provided</div>
                            </div>
                            <div class="field-column">
                                <span class="field-label">Improved Tags</span>
                                <div class="field-content" id="improved-tags">vintage rug, persian runner, boho decor, pink rug, handmade carpet, geometric rug, tribal carpet, oriental runner, turkish rug, bohemian decor, wool rug, hallway runner, area mat</div>
                                <a class="use-improved" id="use-tags">Use these improved tags</a>
                            </div>
                        </div>
                        <div class="improvement-note">Created multi-word tags with better chain structure and increased specificity. All 13 tag slots utilized.</div>
                        
                        <h3>Description</h3>
                        <div class="compare-fields">
                            <div class="field-column">
                                <span class="field-label">Original Description</span>
                                <div class="field-content" id="original-description">No description provided</div>
                            </div>
                            <div class="field-column">
                                <span class="field-label">Improved Description</span>
                                <div class="field-content" id="improved-description">This beautiful vintage Persian runner is a handmade masterpiece that adds bohemian charm to any space. The pink hues create a warm, inviting atmosphere in your home.

**Features:**
* Authentic handcrafted Persian runner with geometric tribal patterns
* Vibrant pink color with bohemian aesthetic
* Made from 100% natural wool for durability and warmth
* Perfect size for hallways, entryways, or as an accent piece
* Unique Oriental Turkish carpet design with rich cultural heritage
* Each rug is handmade, ensuring a one-of-a-kind addition to your home

**Dimensions:** [Add your specific dimensions here]

**Care Instructions:**
* Vacuum regularly on low setting without beater bar
* For spills, blot immediately with clean white cloth
* Professional cleaning recommended for deep cleaning
* Rotate periodically to ensure even wear

**Perfect for:** Adding a touch of elegance to your hallway, entry, or any space needing a pop of color and artistic flair. These vintage-inspired rugs make excellent gifts for new homeowners, boho decor enthusiasts, or anyone appreciating handcrafted textiles.

*Note: Due to the handmade nature of this product, slight variations in color and pattern may occur, making each piece uniquely yours.*</div>
                                <a class="use-improved" id="use-description">Use this improved description</a>
                            </div>
                        </div>
                        <div class="improvement-note">Created a comprehensive description with optimal length, formatting elements (paragraphs, bullet points), and proper keyword integration from the title.</div>
                        
                        <button class="button" id="save-all">Save All Improvements</button>
                    </div>
                </div>
            </section>
        </main>
    </div>
    
    <script>
        // Simple interactive functionality for demo purposes
        document.addEventListener('DOMContentLoaded', function() {
            // Character counter for title
            const titleField = document.getElementById('title');
            const titleCount = document.getElementById('title-count');
            
            function updateTitleCount() {
                const count = titleField.value.length;
                titleCount.textContent = count;
                
                if (count >= 100 && count <= 140) {
                    titleCount.style.color = '#4CAF50';
                } else {
                    titleCount.style.color = count < 100 ? '#FFC107' : '#F44336';
                }
            }
            
            titleField.addEventListener('input', updateTitleCount);
            updateTitleCount(); // Initial count
            
            // Tags input functionality
            const tagsContainer = document.getElementById('tags-container');
            const tagInput = document.getElementById('tag-input');
            const tagCount = document.getElementById('tag-count');
            let tags = [];
            
            function updateTagCount() {
                tagCount.textContent = tags.length;
                if (tags.length >= 13) {
                    tagInput.disabled = true;
                    tagInput.placeholder = "Maximum tags reached (13)";
                } else {
                    tagInput.disabled = false;
                    tagInput.placeholder = "Type a tag and press Enter...";
                }
            }
            
            function renderTags() {
                // Clear existing tags (except input)
                const existingTags = tagsContainer.querySelectorAll('.tag');
                existingTags.forEach(tag => tag.remove());
                
                // Add tags
                tags.forEach((tag, index) => {
                    const tagElement = document.createElement('div');
                    tagElement.className = 'tag';
                    tagElement.innerHTML = tag + '<span class="tag-delete" data-index="' + index + '">×</span>';
                    tagsContainer.insertBefore(tagElement, tagInput);
                });
                
                updateTagCount();
            }
            
            // Add tag when Enter is pressed
            tagInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && tagInput.value.trim() !== '' && tags.length < 13) {
                    e.preventDefault();
                    tags.push(tagInput.value.trim());
                    tagInput.value = '';
                    renderTags();
                }
            });
            
            // Remove tag when delete button is clicked
            tagsContainer.addEventListener('click', function(e) {
                if (e.target.classList.contains('tag-delete')) {
                    const index = parseInt(e.target.dataset.index);
                    tags.splice(index, 1);
                    renderTags();
                }
            });
            
            // Form submission
            const apiKeyInput = document.getElementById('api-key');
            const optimizerForm = document.getElementById('optimizer-form');
            const resultsSection = document.getElementById('results');
            const errorDisplay = document.getElementById('error-display');
            const descriptionField = document.getElementById('description');
            
            // Check if API key exists in localStorage
            if (localStorage.getItem('openai_api_key')) {
                apiKeyInput.value = localStorage.getItem('openai_api_key');
            }
            
            // Function to show error messages
            function showError(message) {
                errorDisplay.textContent = message;
                errorDisplay.classList.remove('hidden');
            }
            
            // Function to call OpenAI API 
            async function optimizeWithOpenAI(apiKey, title, tagsArray, description, field = 'all') {
                const systemPrompt = `
                You are an AI designed to optimize Etsy product listings for maximum search visibility and conversion. 
                Your task is to analyze the provided product listing fields and improve them.
                
                Please optimize the listing based on these key principles:
                
                TITLE OPTIMIZATION:
                - Ideal title length is 100-140 characters
                - Important keywords should appear in the first 40 characters
                - Avoid keyword stuffing or excessive repetition
                - Use a logical structure with 2-4 phrases separated by | (pipes) or commas
                
                TAG OPTIMIZATION:
                - Create 13 tags maximum (Etsy's limit)
                - Use multi-word tags rather than single words
                - Create a mix of broad, medium, and specific tags
                - Include materials, style, use case, and occasion keywords
                - Ensure tags relate to searches real customers would make
                
                DESCRIPTION OPTIMIZATION:
                - Include all important keywords from title and tags naturally
                - Use proper formatting with paragraphs, bullet points, and sections
                - Include product features, benefits, dimensions, and care instructions
                - End with a call to action
                
                Your response should be in JSON format with the following structure:
                {
                    "scores": {
                        "title_score": {
                            "value": 0.0, // From 0 to 4.0
                            "details": {
                                "character_count": {"score": 0.0, "max": 1.2, "passed": true/false},
                                "focus_keywords": {"score": 0.0, "max": 1.2, "passed": true/false},
                                "keyword_stuffing": {"score": 0.0, "max": 0.8, "passed": true/false},
                                "structure": {"score": 0.0, "max": 0.8, "passed": true/false}
                            }
                        },
                        "tags_score": {
                            "value": 0.0, // From 0 to 4.0
                            "details": {
                                "tag_count": {"score": 0.0, "max": 1.0, "passed": true/false},
                                "multi_word_tags": {"score": 0.0, "max": 1.0, "passed": true/false},
                                "chain_structure": {"score": 0.0, "max": 1.0, "passed": true/false},
                                "diversity": {"score": 0.0, "max": 1.0, "passed": true/false}
                            }
                        },
                        "description_score": {
                            "value": 0.0, // From 0 to 4.0
                            "details": {
                                "length": {"score": 0.0, "max": 1.2, "passed": true/false},
                                "formatting": {"score": 0.0, "max": 0.8, "passed": true/false},
                                "keyword_integration": {"score": 0.0, "max": 1.6, "passed": true/false},
                                "call_to_action": {"score": 0.0, "max": 0.4, "passed": true/false}
                            }
                        },
                        "overall_grade": {
                            "value": 0.0, // Weighted average of above scores
                            "letter": "A/B/C/D" // A: ≥3.5, B: ≥2.5, C: ≥1.5, D: <1.5
                        }
                    },
                    "improvements": {
                        "improved_title": "The optimized title",
                        "improved_tags": ["tag1", "tag2", "etc"],
                        "improved_description": "The optimized description",
                        "title_improvement_note": "Brief explanation of title improvements",
                        "tags_improvement_note": "Brief explanation of tag improvements",
                        "description_improvement_note": "Brief explanation of description improvements"
                    }
                }
                `;
                
                // Create the user message with the listing details
                const userMessage = field === 'title' ? 
                    `Please optimize only this Etsy listing title: "${title}"` :
                    field === 'tags' ? 
                    `Please optimize only these Etsy listing tags: ${tagsArray.length > 0 ? tagsArray.join(', ') : 'No tags provided'}` :
                    field === 'description' ? 
                    `Please optimize only this Etsy listing description: ${description || 'No description provided'}` :
                    `
                    Please optimize this Etsy listing:
                    
                    TITLE: ${title}
                    
                    TAGS: ${tagsArray.length > 0 ? tagsArray.join(', ') : 'No tags provided'}
                    
                    DESCRIPTION: ${description || 'No description provided'}
                    `;
                
                try {
                    console.log('Sending request to proxy server...');
                    console.log('API Key length:', apiKey ? apiKey.length : 0);
                    console.log('System prompt length:', systemPrompt.length);
                    console.log('User message length:', userMessage.length);
                    console.log('Field to optimize:', field);
                    
                    // Test the API connectivity first
                    const testResponse = await fetch('/api/test', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ test: 'connection' })
                    });
                    
                    if (!testResponse.ok) {
                        throw new Error(`Test API request failed with status ${testResponse.status}`);
                    }
                    
                    console.log('Test API request successful, now calling main API...');
                    
                    // Use our local proxy server
                    const response = await fetch('/api/classify', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            apiKey,
                            systemPrompt,
                            userPrompt: userMessage,
                            field
                        })
                    });
                    
                    if (!response.ok) {
                        let errorMessage = 'API request failed with status ' + response.status;
                        try {
                            const errorData = await response.json();
                            errorMessage = errorData.error || errorMessage;
                        } catch (e) {
                            // If we can't parse the error as JSON, just use the status code message
                        }
                        throw new Error(errorMessage);
                    }
                    
                    const data = await response.json();
                    
                    // Parse the JSON response from the model
                    const contentText = data.content[0].text;
                    // Extract JSON from the response
                    const jsonMatch = contentText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        return JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('Could not parse optimization result');
                    }
                } catch (error) {
                    console.error('API Error:', error);
                    throw error;
                }
            }
            
            // Function to show field feedback
            function showFeedback(element, message, isSuccess = false) {
                element.textContent = message;
                element.classList.remove('hidden');
                
                if (isSuccess) {
                    element.classList.add('feedback-success');
                } else {
                    element.classList.remove('feedback-success');
                }
            }
            
            // Initialize field-specific buttons
            const titleOnlyBtn = document.getElementById('title-only-btn');
            const tagsOnlyBtn = document.getElementById('tags-only-btn');
            const descriptionOnlyBtn = document.getElementById('description-only-btn');
            const titleFeedback = document.getElementById('title-feedback');
            const tagsFeedback = document.getElementById('tags-feedback');
            const descriptionFeedback = document.getElementById('description-feedback');
            
            // Handle title-only optimization
            titleOnlyBtn.addEventListener('click', async function() {
                // Clear previous feedback
                titleFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Get values
                const apiKey = apiKeyInput.value.trim();
                const title = titleField.value.trim();
                
                if (!apiKey) {
                    showError('Please enter your OpenAI API key');
                    return;
                }
                
                if (!title) {
                    showError('Please enter a product title');
                    return;
                }
                
                // Save API key
                localStorage.setItem('openai_api_key', apiKey);
                
                // Show loading indicator
                titleOnlyBtn.textContent = 'Optimizing...';
                titleOnlyBtn.disabled = true;
                
                try {
                    // Call API for title only
                    const result = await optimizeWithOpenAI(apiKey, title, tags, '', 'title');
                    
                    // Show feedback
                    showFeedback(titleFeedback, result.improvements.title_improvement_note, true);
                    
                    // Update title with improved version
                    titleField.value = result.improvements.improved_title;
                    updateTitleCount();
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Reset button
                    titleOnlyBtn.textContent = 'Optimize Title Only';
                    titleOnlyBtn.disabled = false;
                }
            });
            
            // Handle tags-only optimization
            tagsOnlyBtn.addEventListener('click', async function() {
                // Clear previous feedback
                tagsFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Get values
                const apiKey = apiKeyInput.value.trim();
                const title = titleField.value.trim();
                
                if (!apiKey) {
                    showError('Please enter your OpenAI API key');
                    return;
                }
                
                // Save API key
                localStorage.setItem('openai_api_key', apiKey);
                
                // Show loading indicator
                tagsOnlyBtn.textContent = 'Optimizing...';
                tagsOnlyBtn.disabled = true;
                
                try {
                    // Call API for tags only
                    const result = await optimizeWithOpenAI(apiKey, title, tags, '', 'tags');
                    
                    // Show feedback
                    showFeedback(tagsFeedback, result.improvements.tags_improvement_note, true);
                    
                    // Update tags with improved version
                    tags = result.improvements.improved_tags;
                    renderTags();
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Reset button
                    tagsOnlyBtn.textContent = 'Optimize Tags Only';
                    tagsOnlyBtn.disabled = false;
                }
            });
            
            // Handle description-only optimization
            descriptionOnlyBtn.addEventListener('click', async function() {
                // Clear previous feedback
                descriptionFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Get values
                const apiKey = apiKeyInput.value.trim();
                const title = titleField.value.trim();
                const description = descriptionField.value.trim();
                
                if (!apiKey) {
                    showError('Please enter your OpenAI API key');
                    return;
                }
                
                // Save API key
                localStorage.setItem('openai_api_key', apiKey);
                
                // Show loading indicator
                descriptionOnlyBtn.textContent = 'Optimizing...';
                descriptionOnlyBtn.disabled = true;
                
                try {
                    // Call API for description only
                    const result = await optimizeWithOpenAI(apiKey, title, tags, description, 'description');
                    
                    // Show feedback
                    showFeedback(descriptionFeedback, result.improvements.description_improvement_note, true);
                    
                    // Update description with improved version
                    descriptionField.value = result.improvements.improved_description;
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Reset button
                    descriptionOnlyBtn.textContent = 'Optimize Description Only';
                    descriptionOnlyBtn.disabled = false;
                }
            });
            
            // Handle form submission (optimize all)
            optimizerForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                // Clear previous errors and feedback
                errorDisplay.classList.add('hidden');
                errorDisplay.textContent = '';
                titleFeedback.classList.add('hidden');
                tagsFeedback.classList.add('hidden');
                descriptionFeedback.classList.add('hidden');
                
                // Get form values
                const apiKey = apiKeyInput.value.trim();
                const title = titleField.value.trim();
                const description = descriptionField.value.trim();
                
                // Validate inputs
                if (!apiKey) {
                    showError('Please enter your OpenAI API key');
                    return;
                }
                
                if (!title) {
                    showError('Please enter a product title');
                    return;
                }
                
                // Save API key to localStorage
                localStorage.setItem('openai_api_key', apiKey);
                
                // Show loading overlay
                document.querySelector('.loading').style.display = 'flex';
                
                try {
                    // Call OpenAI API for full optimization
                    const result = await optimizeWithOpenAI(apiKey, title, tags, description, 'all');
                    
                    // Update UI with results
                    updateResults(result, title, tags, description);
                    
                    // Show results section
                    resultsSection.classList.remove('hidden');
                    
                    // Smoothly scroll to results
                    resultsSection.scrollIntoView({ behavior: 'smooth' });
                    
                    // Show success feedback on all fields
                    showFeedback(titleFeedback, "Title optimized successfully!", true);
                    showFeedback(tagsFeedback, "Tags optimized successfully!", true);
                    showFeedback(descriptionFeedback, "Description optimized successfully!", true);
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Hide loading overlay
                    document.querySelector('.loading').style.display = 'none';
                }
            });
            
            // Function to update UI with optimization results
            function updateResults(result, originalTitle, originalTags, originalDescription) {
                // Update score cards
                document.querySelector('.score.grade-b .score-value').textContent = 
                    result.scores.overall_grade.value.toFixed(1) + '/4.0';
                document.querySelector('.score.grade-b').className = 
                    'score grade-' + result.scores.overall_grade.letter.toLowerCase();
                
                // Update title score
                const titleScoreElement = document.querySelector('.score-card:nth-child(2) .score-value');
                titleScoreElement.textContent = result.scores.title_score.value.toFixed(1) + '/4.0';
                
                const titleDetails = document.querySelector('.score-card:nth-child(2) .score-details');
                titleDetails.innerHTML = `
                    <div>${result.scores.title_score.details.character_count.passed ? '✓' : '✗'} Character Count: ${result.scores.title_score.details.character_count.score.toFixed(1)}/${result.scores.title_score.details.character_count.max.toFixed(1)}</div>
                    <div>${result.scores.title_score.details.focus_keywords.passed ? '✓' : '✗'} Focus Keywords: ${result.scores.title_score.details.focus_keywords.score.toFixed(1)}/${result.scores.title_score.details.focus_keywords.max.toFixed(1)}</div>
                    <div>${result.scores.title_score.details.keyword_stuffing.passed ? '✓' : '✗'} Keyword Stuffing: ${result.scores.title_score.details.keyword_stuffing.score.toFixed(1)}/${result.scores.title_score.details.keyword_stuffing.max.toFixed(1)}</div>
                    <div>${result.scores.title_score.details.structure.passed ? '✓' : '✗'} Structure: ${result.scores.title_score.details.structure.score.toFixed(1)}/${result.scores.title_score.details.structure.max.toFixed(1)}</div>
                `;
                
                // Update tags score
                const tagsScoreElement = document.querySelector('.score-card:nth-child(3) .score-value');
                tagsScoreElement.textContent = result.scores.tags_score.value.toFixed(1) + '/4.0';
                
                const tagsDetails = document.querySelector('.score-card:nth-child(3) .score-details');
                tagsDetails.innerHTML = `
                    <div>${result.scores.tags_score.details.tag_count.passed ? '✓' : '✗'} Tag Count: ${result.scores.tags_score.details.tag_count.score.toFixed(1)}/${result.scores.tags_score.details.tag_count.max.toFixed(1)}</div>
                    <div>${result.scores.tags_score.details.multi_word_tags.passed ? '✓' : '✗'} Multi-word Tags: ${result.scores.tags_score.details.multi_word_tags.score.toFixed(1)}/${result.scores.tags_score.details.multi_word_tags.max.toFixed(1)}</div>
                    <div>${result.scores.tags_score.details.chain_structure.passed ? '✓' : '✗'} Chain Structure: ${result.scores.tags_score.details.chain_structure.score.toFixed(1)}/${result.scores.tags_score.details.chain_structure.max.toFixed(1)}</div>
                    <div>${result.scores.tags_score.details.diversity.passed ? '✓' : '✗'} Diversity: ${result.scores.tags_score.details.diversity.score.toFixed(1)}/${result.scores.tags_score.details.diversity.max.toFixed(1)}</div>
                `;
                
                // Update description score
                const descScoreElement = document.querySelector('.score-card:nth-child(4) .score-value');
                descScoreElement.textContent = result.scores.description_score.value.toFixed(1) + '/4.0';
                
                const descDetails = document.querySelector('.score-card:nth-child(4) .score-details');
                descDetails.innerHTML = `
                    <div>${result.scores.description_score.details.length.passed ? '✓' : '✗'} Length: ${result.scores.description_score.details.length.score.toFixed(1)}/${result.scores.description_score.details.length.max.toFixed(1)}</div>
                    <div>${result.scores.description_score.details.formatting.passed ? '✓' : '✗'} Formatting: ${result.scores.description_score.details.formatting.score.toFixed(1)}/${result.scores.description_score.details.formatting.max.toFixed(1)}</div>
                    <div>${result.scores.description_score.details.keyword_integration.passed ? '✓' : '✗'} Keyword Integration: ${result.scores.description_score.details.keyword_integration.score.toFixed(1)}/${result.scores.description_score.details.keyword_integration.max.toFixed(1)}</div>
                    <div>${result.scores.description_score.details.call_to_action.passed ? '✓' : '✗'} Call to Action: ${result.scores.description_score.details.call_to_action.score.toFixed(1)}/${result.scores.description_score.details.call_to_action.max.toFixed(1)}</div>
                `;
                
                // Update original and improved content
                document.getElementById('original-title').textContent = originalTitle;
                document.getElementById('improved-title').textContent = result.improvements.improved_title;
                document.getElementById('original-tags').textContent = originalTags.length > 0 ? originalTags.join(', ') : 'No tags provided';
                document.getElementById('improved-tags').textContent = result.improvements.improved_tags.join(', ');
                document.getElementById('original-description').textContent = originalDescription || 'No description provided';
                document.getElementById('improved-description').textContent = result.improvements.improved_description;
                
                // Update improvement notes
                document.querySelector('.improvement-note:nth-of-type(1)').textContent = result.improvements.title_improvement_note;
                document.querySelector('.improvement-note:nth-of-type(2)').textContent = result.improvements.tags_improvement_note;
                document.querySelector('.improvement-note:nth-of-type(3)').textContent = result.improvements.description_improvement_note;
            }
            
            // Tabs functionality
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs
                    tabs.forEach(t => t.classList.remove('active'));
                    // Add active class to clicked tab
                    this.classList.add('active');
                    
                    // Hide all tab contents
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // Show selected tab content
                    const tabId = this.dataset.tab + '-tab';
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // "Use improved" functionality
            document.getElementById('use-title').addEventListener('click', function() {
                titleField.value = document.getElementById('improved-title').textContent;
                updateTitleCount();
            });
            
            document.getElementById('use-tags').addEventListener('click', function() {
                const improvedTags = document.getElementById('improved-tags').textContent.split(', ');
                tags = improvedTags;
                renderTags();
            });
            
            document.getElementById('use-description').addEventListener('click', function() {
                document.getElementById('description').value = document.getElementById('improved-description').textContent;
            });
            
            document.getElementById('save-all').addEventListener('click', function() {
                document.getElementById('use-title').click();
                document.getElementById('use-tags').click();
                document.getElementById('use-description').click();
                
                alert('All improvements have been applied to your listing!');
            });
        });
    </script>
</body>
</html>

================
File: package.json
================
{
  "name": "text-classifier",
  "version": "1.0.0",
  "description": "Text classification using OpenAI API",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "node-fetch": "^2.6.9"
  }
}

================
File: README.md
================
# Text Classifier with OpenAI API

This is a simple web application that uses the OpenAI GPT-4 API to classify text into different categories.

## Features

- Classify text into predefined categories (sentiment, content type, topic, intent)
- Create custom classification categories
- Get detailed results with confidence scores and explanations
- Per-field feedback and optimization
- Simple and intuitive user interface

## Setup

1. Make sure you have Node.js installed on your machine
2. Clone this repository
3. Install dependencies:

```bash
npm install
```

4. Start the server:

```bash
npm start
```

5. Open your browser and navigate to: http://localhost:3000/classify.html

## Usage

1. Enter your OpenAI API key (you can get one from https://platform.openai.com/api-keys)
2. Enter the text you want to classify
3. Select a classification type:
   - Choose from predefined categories (sentiment, content type, topic, intent)
   - Or define your own custom categories (comma-separated)
4. You can:
   - Click "Classify Text" button for full classification
   - Click "Classify Text Only" to get feedback on your text
   - Click "Validate Categories" to check your custom categories
5. View the detailed classification results

## How it Works

The application uses a Node.js server to proxy requests to the OpenAI API, avoiding CORS issues. The classification is performed by GPT-4, OpenAI's powerful language model.

The app provides:
- A primary classification with confidence score
- Breakdown of all category scores
- Explanation of the classification decision
- Per-field feedback and optimization options

## Privacy

Your API key is stored only in your browser's local storage and is never saved on our servers. All API requests are made directly from your browser to the OpenAI API through our proxy server.

## Requirements

- Node.js 14+
- A valid OpenAI API key

================
File: server.js
================
const express = require('express');
const cors = require('cors');
const fetch = require('node-fetch');
const app = express();
const port = 3000;

// Enable CORS for all routes
app.use(cors());

// Parse JSON request bodies
app.use(express.json({ limit: '10mb' }));

// Add request logging middleware
app.use((req, res, next) => {
  const start = Date.now();
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path} started`);
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path} completed with ${res.statusCode} in ${duration}ms`);
  });
  
  next();
});

// Serve static files from the current directory
app.use(express.static('./'));

// Simple test endpoint
app.post('/api/test', (req, res) => {
  console.log('Test endpoint received:', req.body);
  res.json({ message: 'Test endpoint successful!', received: req.body });
});

// Proxy endpoint for OpenAI API
app.post('/api/classify', async (req, res) => {
    console.log('Classify endpoint called');
    const { apiKey, systemPrompt, userPrompt, field } = req.body;
    
    if (!apiKey) {
        console.log('API key missing');
        return res.status(400).json({ error: 'API key is required' });
    }
    
    // Log the prompts for debugging
    console.log('System prompt:', systemPrompt ? systemPrompt.substring(0, 100) + '...' : 'undefined');
    console.log('User prompt:', userPrompt ? userPrompt.substring(0, 100) + '...' : 'undefined');
    console.log('Field:', field || 'all');
    
    try {
        console.log('Calling OpenAI API...');
        
        const requestBody = {
            model: 'gpt-4',
            max_tokens: 4000,
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userPrompt }
            ]
        };
        
        console.log('Request body:', JSON.stringify(requestBody).substring(0, 150) + '...');
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify(requestBody)
        });
        
        console.log('OpenAI API response status:', response.status);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('API Error Response:', errorText);
            
            try {
                const errorData = JSON.parse(errorText);
                return res.status(response.status).json({ 
                    error: errorData.error?.message || 'OpenAI API error' 
                });
            } catch (e) {
                return res.status(response.status).json({ 
                    error: `OpenAI API returned status ${response.status}` 
                });
            }
        }
        
        const data = await response.json();
        console.log('API response received successfully');
        
        // Transform OpenAI response format to match what our client code expects
        const transformedResponse = {
            content: [
                {
                    text: data.choices[0].message.content
                }
            ],
            field: field || 'all'
        };
        
        res.json(transformedResponse);
    } catch (error) {
        console.error('Error calling OpenAI API:', error);
        res.status(500).json({ error: 'Failed to call OpenAI API: ' + error.message });
    }
});

// Provide a helpful 404 for any other routes
app.use((req, res) => {
  res.status(404).json({
    error: 'Not Found',
    message: `The endpoint ${req.method} ${req.path} does not exist`,
    availableEndpoints: [
      { method: 'POST', path: '/api/classify', description: 'Proxy to OpenAI API' },
      { method: 'POST', path: '/api/test', description: 'Test endpoint' },
      { method: 'GET', path: '/', description: 'Static files' }
    ]
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Server error:', err);
  res.status(500).json({ error: 'Internal Server Error', message: err.message });
});

// Start the server
app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}`);
    console.log(`Available applications:`);
    console.log(`- Etsy Listing Optimizer: http://localhost:${port}/index.html`);
    console.log(`- Text Classifier: http://localhost:${port}/classify.html`);
    console.log(`- API Test: http://localhost:${port}/test.html`);
});

================
File: test-server.js
================
const express = require('express');
const app = express();
const port = 3001;

// Enable JSON parsing
app.use(express.json());

// Add logging middleware
app.use((req, res, next) => {
  console.log(`${req.method} ${req.path}`);
  next();
});

// Simple test endpoint
app.post('/api/test', (req, res) => {
  console.log('Request body:', req.body);
  res.json({ message: 'Test endpoint successful!', received: req.body });
});

// Start the server
app.listen(port, () => {
  console.log(`Test server running at http://localhost:${port}`);
  console.log('To test the server, run:');
  console.log('curl -X POST -H "Content-Type: application/json" -d \'{"test":"data"}\' http://localhost:3001/api/test');
});

================
File: test.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 0;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow: auto;
        }
    </style>
</head>
<body>
    <h1>API Test Page</h1>
    <p>This page tests communication with the server API endpoints.</p>
    
    <h2>Test Local Endpoint</h2>
    <div>
        <button id="test-btn">Test API</button>
    </div>
    <pre id="test-result">Results will appear here...</pre>
    
    <h2>Debug Information</h2>
    <div>
        <button id="debug-btn">Show Debug Info</button>
    </div>
    <pre id="debug-info"></pre>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const testBtn = document.getElementById('test-btn');
            const testResult = document.getElementById('test-result');
            const debugBtn = document.getElementById('debug-btn');
            const debugInfo = document.getElementById('debug-info');
            
            // Test API button
            testBtn.addEventListener('click', async function() {
                testResult.textContent = 'Testing API...';
                
                try {
                    console.log('Sending test request...');
                    const response = await fetch('http://localhost:3001/api/test', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            test: 'data',
                            timestamp: new Date().toISOString()
                        })
                    });
                    
                    console.log('Response status:', response.status);
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    const data = await response.json();
                    testResult.textContent = JSON.stringify(data, null, 2);
                } catch (error) {
                    console.error('Error testing API:', error);
                    testResult.textContent = 'Error: ' + error.message;
                }
            });
            
            // Debug button
            debugBtn.addEventListener('click', function() {
                const info = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    cookiesEnabled: navigator.cookieEnabled,
                    language: navigator.language,
                    online: navigator.onLine,
                    screenSize: {
                        width: window.innerWidth,
                        height: window.innerHeight
                    },
                    timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    currentTime: new Date().toISOString()
                };
                
                debugInfo.textContent = JSON.stringify(info, null, 2);
            });
        });
    </script>
</body>
</html>



================================================================
End of Codebase
================================================================
