
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Etsy Listing Optimizer</title>
    <style>
        :root {
            --etsy-orange: #F56400;
            --etsy-hover: #E55400;
            --etsy-light: #FFF3ED;
            --gray-light: #f5f5f5;
            --gray-med: #e0e0e0;
            --gray-dark: #767676;
            --success-green: #4CAF50;
            --warning-orange: #FFC107;
            --a-color: #DCEDC8;
            --b-color: #FFF9C4;
            --c-color: #FFE0B2;
            --d-color: #FFCCBC;
        }
        
        * {
            box-sizing: border-box;
            font-family: 'Graphik Webfont', -apple-system, 'Helvetica Neue', 'Droid Sans', Arial, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 0;
            background-color: #f7f7f7;
            color: #222;
            line-height: 1.4;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: white;
            border-bottom: 1px solid var(--gray-med);
            padding: 15px 0;
        }
        
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--etsy-orange);
            text-decoration: none;
            margin-left: 20px;
        }
        
        main {
            display: flex;
            flex-wrap: wrap;
            margin-top: 30px;
            gap: 20px;
        }
        
        .input-section {
            flex: 1 1 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .results-section {
            flex: 1 1 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .score-cards {
            flex: 1 1 300px;
        }
        
        .improvements {
            flex: 2 1 600px;
        }
        
        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }
        
        h1, h2, h3 {
            margin-top: 0;
            color: #222;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        textarea, input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--gray-med);
            border-radius: 6px;
            font-size: 16px;
            margin-bottom: 15px;
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        
        .tags-input {
            display: flex;
            flex-wrap: wrap;
            border: 1px solid var(--gray-med);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 15px;
            min-height: 48px;
        }
        
        .tag {
            display: inline-flex;
            align-items: center;
            background: var(--etsy-light);
            color: var(--etsy-orange);
            padding: 4px 8px;
            border-radius: 4px;
            margin: 4px;
            font-size: 14px;
        }
        
        .tag-delete {
            margin-left: 6px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .tags-input input {
            flex: 1;
            border: none;
            outline: none;
            padding: 8px;
            font-size: 14px;
            min-width: 120px;
        }
        
        .button {
            background-color: var(--etsy-orange);
            color: white;
            border: none;
            border-radius: 24px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .button:hover {
            background-color: var(--etsy-hover);
        }
        
        .score {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 6px;
            background-color: var(--gray-light);
        }
        
        .score-label {
            font-weight: 500;
        }
        
        .score-value {
            font-size: 18px;
            font-weight: bold;
        }
        
        .score-card {
            margin-bottom: 10px;
        }
        
        .score-details {
            margin-top: 5px;
            font-size: 14px;
            color: var(--gray-dark);
        }
        
        .detail-info {
            display: block;
            margin-left: 20px;
            font-size: 12px;
            color: var(--gray-dark);
            font-style: italic;
        }
        
        .grade-a {
            background-color: #DCEDC8;
        }
        
        .grade-b {
            background-color: #FFF9C4;
        }
        
        .grade-c {
            background-color: #FFE0B2;
        }
        
        .grade-d {
            background-color: #FFCCBC;
        }
        
        .compare-fields {
            display: flex;
            margin-bottom: 20px;
            gap: 20px;
        }
        
        .field-column {
            flex: 1;
        }
        
        .field-label {
            font-weight: 500;
            margin-bottom: 5px;
            display: block;
        }
        
        .field-content {
            padding: 15px;
            background: var(--gray-light);
            border-radius: 6px;
            min-height: 100px;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        
        .use-improved {
            font-size: 14px;
            color: var(--etsy-orange);
            text-decoration: underline;
            cursor: pointer;
            display: inline-block;
            margin-bottom: 15px;
        }
        
        .improvement-note {
            color: var(--gray-dark);
            font-size: 14px;
            font-style: italic;
            margin-bottom: 10px;
        }
        
        .tag-count {
            color: var(--gray-dark);
            font-size: 14px;
            margin-top: 5px;
        }
        
        .tag-length {
            font-size: 12px;
            margin-left: 5px;
            color: var(--gray-dark);
        }
        
        .tag-length-warn {
            color: var(--warning-orange);
        }
        
        .tag-length-error {
            color: #F44336;
        }
        
        .loading {
            display: none;
            align-items: center;
            justify-content: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--gray-med);
            border-top: 4px solid var(--etsy-orange);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
        
        .help-tip {
            font-size: 14px;
            color: var(--gray-dark);
            margin-bottom: 10px;
        }
        
        .error-message {
            color: #F44336;
            font-weight: bold;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
            background-color: #FFEBEE;
        }
        
        .feedback-message {
            background-color: #FFF3ED;
            color: #E55400;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 5px;
            margin-bottom: 10px;
            border-left: 4px solid #F56400;
        }
        
        .feedback-success {
            background-color: #E8F5E9;
            border-left: 4px solid #4CAF50;
            color: #1B5E20;
        }
        
        .feedback-message ul {
            margin: 8px 0;
            padding-left: 20px;
        }
        
        .feedback-message li {
            margin-bottom: 5px;
        }
        
        .feedback-message p {
            margin: 8px 0 0 0;
            font-style: italic;
        }
        
        .secondary-button {
            background-color: #FFFFFF;
            color: var(--etsy-orange);
            border: 1px solid var(--etsy-orange);
            border-radius: 24px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-right: 10px;
            margin-top: 5px;
        }
        
        .secondary-button:hover {
            background-color: var(--etsy-light);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--gray-med);
        }
        
        .tab {
            padding: 12px 24px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
        }
        
        .tab.active {
            border-bottom-color: var(--etsy-orange);
            color: var(--etsy-orange);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @media (max-width: 768px) {
            .compare-fields {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header>
        <a href="#" class="logo">Etsy Listing Optimizer</a>
    </header>
    
    <div class="container">
        <main>
            <section class="input-section">
                <h1>Optimize Your Etsy Listing</h1>
                <p>Enter your listing details below to receive personalized optimization suggestions based on Etsy's search algorithm.</p>
                
                <div class="tabs">
                    <div class="tab active" data-tab="single">Single Listing</div>
                    <div class="tab" data-tab="batch">Batch Optimizer</div>
                </div>
                
                <div class="tab-content active" id="single-tab">
                    <form id="optimizer-form">
                        <div>
                            <label for="title">Product Title:</label>
                            <textarea id="title" placeholder="Enter your product title here...">Vintage Persian Runner Boho Pink Rug Handmade, Geometric Tribal Oriental Turkish Carpet, Bohemian Wool Hallway Entry Decor Small Area Mat</textarea>
                            <div class="help-tip">Character count: <span id="title-count">0</span>/140 (100-140 characters recommended)</div>
                            <div class="feedback-message hidden" id="title-feedback"></div>
                            <button type="button" id="title-only-btn" class="secondary-button">Optimize Title Only</button>
                            <button type="button" id="title-grade-btn" class="secondary-button">Grade Title Only</button>
                        </div>
                        
                        <div>
                            <label for="tags">Tags (max 13):</label>
                            <div class="tags-input" id="tags-container">
                                <input type="text" id="tag-input" placeholder="Type a tag and press Enter or paste comma-separated list...">
                            </div>
                            <div class="help-tip">Pro tip: Paste comma-separated tags to add multiple tags at once (max 20 chars per tag, duplicates skipped)</div>
                            <div class="tag-count"><span id="tag-count">0</span>/13 tags used</div>
                            <div class="feedback-message hidden" id="tags-feedback"></div>
                            <button type="button" id="tags-only-btn" class="secondary-button">Optimize Tags Only</button>
                            <button type="button" id="tags-grade-btn" class="secondary-button">Grade Tags Only</button>
                        </div>
                        
                        <div>
                            <label for="description">Product Description:</label>
                            <textarea id="description" placeholder="Enter your product description here..."></textarea>
                            <div class="feedback-message hidden" id="description-feedback"></div>
                            <button type="button" id="description-only-btn" class="secondary-button">Optimize Description Only</button>
                            <button type="button" id="description-grade-btn" class="secondary-button">Grade Description Only</button>
                        </div>
                        
                        <div class="error-message hidden" id="error-display"></div>
                        
                        <button type="submit" class="button">Analyze & Optimize All</button>
                        <button type="button" id="grade-all-btn" class="button" style="background-color: #4CAF50; margin-left: 10px;">Grade All</button>
                    </form>
                </div>
                
                <div class="tab-content" id="batch-tab">
                    <p>Upload a CSV file with multiple listings to analyze and optimize in bulk.</p>
                    <input type="file" id="batch-file" accept=".csv">
                    <div class="help-tip">CSV should have columns for: title, tags, description</div>
                    <button class="button" id="batch-analyze">Upload & Analyze</button>
                </div>
            </section>
            
            <section class="results-section hidden" id="results">
                <div class="loading">
                    <div class="loading-spinner"></div>
                </div>
                
                <div class="score-cards">
                    <div class="card">
                        <h2>Listing Scores</h2>
                        
                        <div class="score grade-b">
                            <div class="score-label">Overall Grade</div>
                            <div class="score-value">3.0/4.0</div>
                        </div>
                        
                        <div class="score-card">
                            <div class="score-label">Title Score</div>
                            <div class="score-value">2.8/4.0</div>
                            <div class="score-details">
                                <div>✓ Character Count: 1.2/1.2</div>
                                <div>✗ Focus Keywords: 0/1.2</div>
                                <div>✓ Keyword Stuffing: 0.8/0.8</div>
                                <div>✓ Structure: 0.8/0.8</div>
                            </div>
                        </div>
                        
                        <div class="score-card">
                            <div class="score-label">Tags Score</div>
                            <div class="score-value">3.0/4.0</div>
                            <div class="score-details">
                                <div>✓ Tag Count: 1.0/1.0</div>
                                <div>✓ Multi-word Tags: 1.0/1.0</div>
                                <div>✗ Chain Structure: 0.5/1.0</div>
                                <div>✓ Diversity: 0.5/1.0</div>
                            </div>
                        </div>
                        
                        <div class="score-card">
                            <div class="score-label">Description Score</div>
                            <div class="score-value">3.2/4.0</div>
                            <div class="score-details">
                                <div>✓ Length: 1.2/1.2</div>
                                <div>✓ Formatting: 0.8/0.8</div>
                                <div>✓ Keyword Integration: 1.2/1.6</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="improvements">
                    <div class="card">
                        <h2>Optimization Suggestions</h2>
                        
                        <h3>Title</h3>
                        <div class="compare-fields">
                            <div class="field-column">
                                <span class="field-label">Original Title</span>
                                <div class="field-content" id="original-title">Vintage Persian Runner Boho Pink Rug Handmade, Geometric Tribal Oriental Turkish Carpet, Bohemian Wool Hallway Entry Decor Small Area Mat</div>
                            </div>
                            <div class="field-column">
                                <span class="field-label">Improved Title</span>
                                <div class="field-content" id="improved-title">Vintage Persian Runner Boho Pink Rug Handmade | Geometric Tribal Oriental Turkish Carpet | Bohemian Wool Hallway Entry Decor Small Area Mat</div>
                                <a class="use-improved" id="use-title">Use this improved title</a>
                            </div>
                        </div>
                        <div class="improvement-note">Changed commas to pipes (|) for better visual separation and improved readability.</div>
                        
                        <h3>Tags</h3>
                        <div class="compare-fields">
                            <div class="field-column">
                                <span class="field-label">Original Tags</span>
                                <div class="field-content" id="original-tags">No tags provided</div>
                            </div>
                            <div class="field-column">
                                <span class="field-label">Improved Tags</span>
                                <div class="field-content" id="improved-tags">vintage rug, persian runner, boho decor, pink rug, handmade carpet, geometric rug, tribal carpet, oriental runner, turkish rug, bohemian decor, wool rug, hallway runner, area mat</div>
                                <a class="use-improved" id="use-tags">Use these improved tags</a>
                            </div>
                        </div>
                        <div class="improvement-note">Created multi-word tags with better chain structure and increased specificity. All 13 tag slots utilized.</div>
                        
                        <h3>Description</h3>
                        <div class="compare-fields">
                            <div class="field-column">
                                <span class="field-label">Original Description</span>
                                <div class="field-content" id="original-description">No description provided</div>
                            </div>
                            <div class="field-column">
                                <span class="field-label">Improved Description</span>
                                <div class="field-content" id="improved-description">This beautiful vintage Persian runner is a handmade masterpiece that adds bohemian charm to any space. The pink hues create a warm, inviting atmosphere in your home.

**Features:**
* Authentic handcrafted Persian runner with geometric tribal patterns
* Vibrant pink color with bohemian aesthetic
* Made from 100% natural wool for durability and warmth
* Perfect size for hallways, entryways, or as an accent piece
* Unique Oriental Turkish carpet design with rich cultural heritage
* Each rug is handmade, ensuring a one-of-a-kind addition to your home

**Dimensions:** [Add your specific dimensions here]

**Care Instructions:**
* Vacuum regularly on low setting without beater bar
* For spills, blot immediately with clean white cloth
* Professional cleaning recommended for deep cleaning
* Rotate periodically to ensure even wear

**Perfect for:** Adding a touch of elegance to your hallway, entry, or any space needing a pop of color and artistic flair. These vintage-inspired rugs make excellent gifts for new homeowners, boho decor enthusiasts, or anyone appreciating handcrafted textiles.

*Note: Due to the handmade nature of this product, slight variations in color and pattern may occur, making each piece uniquely yours.*</div>
                                <a class="use-improved" id="use-description">Use this improved description</a>
                            </div>
                        </div>
                        <div class="improvement-note">Created a comprehensive description with optimal length, formatting elements (paragraphs, bullet points), and proper keyword integration from the title.</div>
                        
                        <button class="button" id="save-all">Save All Improvements</button>
                    </div>
                </div>
            </section>
        </main>
    </div>
    
    <script>
        // Simple interactive functionality for demo purposes
        document.addEventListener('DOMContentLoaded', function() {
            // Character counter for title
            const titleField = document.getElementById('title');
            const titleCount = document.getElementById('title-count');
            
            function updateTitleCount() {
                const count = titleField.value.length;
                titleCount.textContent = count;
                
                if (count >= 100 && count <= 140) {
                    titleCount.style.color = '#4CAF50';
                } else {
                    titleCount.style.color = count < 100 ? '#FFC107' : '#F44336';
                }
            }
            
            titleField.addEventListener('input', updateTitleCount);
            updateTitleCount(); // Initial count
            
            // Tags input functionality
            const tagsContainer = document.getElementById('tags-container');
            const tagInput = document.getElementById('tag-input');
            const tagCount = document.getElementById('tag-count');
            let tags = [];
            
            function updateTagCount() {
                tagCount.textContent = tags.length;
                if (tags.length >= 13) {
                    tagInput.disabled = true;
                    tagInput.placeholder = "Maximum tags reached (13)";
                } else {
                    tagInput.disabled = false;
                    tagInput.placeholder = "Type a tag and press Enter or paste comma-separated list...";
                }
            }
            
            function renderTags() {
                // Clear existing tags (except input)
                const existingTags = tagsContainer.querySelectorAll('.tag');
                existingTags.forEach(tag => tag.remove());
                
                // Add tags
                tags.forEach((tag, index) => {
                    const tagElement = document.createElement('div');
                    tagElement.className = 'tag';
                    
                    // Add character count indicator with color
                    let lengthClass = '';
                    if (tag.length > 20) {
                        lengthClass = 'tag-length-error';
                    } else if (tag.length > 15) {
                        lengthClass = 'tag-length-warn';
                    }
                    
                    tagElement.innerHTML = tag + 
                        `<span class="tag-length ${lengthClass}">(${tag.length})</span>` + 
                        '<span class="tag-delete" data-index="' + index + '">×</span>';
                    
                    tagsContainer.insertBefore(tagElement, tagInput);
                });
                
                updateTagCount();
            }
            
            // Add real-time tag length validation
            tagInput.addEventListener('input', function() {
                const currentLength = this.value.trim().length;
                
                // Show warning if approaching or exceeding max length
                if (currentLength > 20) {
                    showError(`Tag is too long (${currentLength}/20). Must be 20 characters or less.`);
                } else if (currentLength > 15) {
                    // Use warning but don't prevent submission
                    errorDisplay.textContent = `Tag length: ${currentLength}/20 (approaching limit)`;
                    errorDisplay.classList.remove('hidden');
                    errorDisplay.style.color = 'var(--warning-orange)';
                    errorDisplay.style.fontWeight = 'normal';
                } else if (errorDisplay.textContent.includes('Tag length') || errorDisplay.textContent.includes('Tag is too long')) {
                    // Clear the error if it was a tag length error
                    errorDisplay.classList.add('hidden');
                }
            });
            
            // Function to add a single tag
            function addTag(newTag) {
                newTag = newTag.trim();
                if (newTag === '' || tags.length >= 13) return false;
                
                // Validate tag length (max 20 characters)
                if (newTag.length > 20) {
                    showError(`Tag skipped: "${newTag}" is too long (${newTag.length}/20). Must be 20 characters or less.`);
                    return false;
                }
                
                // Check for duplicates
                if (tags.includes(newTag)) {
                    showError(`Tag skipped: "${newTag}" is already in your tag list.`);
                    return false;
                }
                
                tags.push(newTag);
                return true;
            }
            
            // Function to process comma-separated tags
            function processCommaSeparatedTags(input) {
                const tagsList = input.split(',');
                let addedCount = 0;
                let skippedCount = 0;
                
                for (const tag of tagsList) {
                    if (tags.length >= 13) break;
                    
                    if (addTag(tag)) {
                        addedCount++;
                    } else {
                        skippedCount++;
                    }
                }
                
                if (addedCount > 0) {
                    renderTags();
                    
                    // Show summary message
                    if (skippedCount > 0) {
                        showError(`Added ${addedCount} tags. Skipped ${skippedCount} tags (duplicates or too long).`);
                    } else {
                        errorDisplay.classList.add('hidden');
                    }
                }
                
                return addedCount;
            }
            
            // Add tag when Enter is pressed or when pasting comma-separated list
            tagInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && tagInput.value.trim() !== '') {
                    e.preventDefault();
                    
                    // Check if input contains commas (comma-separated list)
                    if (tagInput.value.includes(',')) {
                        processCommaSeparatedTags(tagInput.value);
                    } else {
                        addTag(tagInput.value) && renderTags();
                    }
                    
                    tagInput.value = '';
                    
                    // Clear error if it was related to tag input
                    if (errorDisplay.textContent.includes('Tag length') || 
                        errorDisplay.textContent.includes('Tag is too long') ||
                        !errorDisplay.textContent.includes('skipped')) {
                        errorDisplay.classList.add('hidden');
                    }
                }
            });
            
            // Also handle paste events to automatically process comma-separated lists
            tagInput.addEventListener('paste', function(e) {
                // Wait for the paste to complete before processing
                setTimeout(() => {
                    if (tagInput.value.includes(',')) {
                        processCommaSeparatedTags(tagInput.value);
                        tagInput.value = '';
                    }
                }, 0);
            });
            
            // Remove tag when delete button is clicked
            tagsContainer.addEventListener('click', function(e) {
                if (e.target.classList.contains('tag-delete')) {
                    const index = parseInt(e.target.dataset.index);
                    tags.splice(index, 1);
                    renderTags();
                }
            });
            
            // Form submission
            // API key is now stored on the server
            const optimizerForm = document.getElementById('optimizer-form');
            const resultsSection = document.getElementById('results');
            const errorDisplay = document.getElementById('error-display');
            const descriptionField = document.getElementById('description');
            
            // API key is now stored on the server
            
            // Function to show error messages
            function showError(message) {
                errorDisplay.textContent = message;
                errorDisplay.classList.remove('hidden');
            }
            
            // Function to call OpenAI API 
            async function optimizeWithOpenAI(title, tagsArray, description, field = 'all') {
                const systemPrompt = `
                You are an AI designed to optimize Etsy product listings for maximum search visibility and conversion. 
                Your task is to analyze the provided product listing fields and improve them.
                
                Follow the exact scoring framework below:
                
                OVERALL GRADE CALCULATION:
                - Overall score = (Title score × 0.40) + (Tag score × 0.40) + (Description score × 0.20)
                - Grade Scale:
                  - A: 3.5-4.0
                  - B: 2.5-3.49
                  - C: 1.5-2.49
                  - D: 1.0-1.49
                
                TITLE OPTIMIZATION CRITERIA:
                1. Character Count (1.2 points)
                   - 100-140 characters: 1.2 points
                   - 80-99 characters: 0.9 points
                   - 141-160 characters: 0.6 points
                   - <80 or >160 characters: 0.3 points
                
                2. Focus Keywords in First 40 Characters (1.2 points)
                   - Definition: Number of significant words (>3 characters) that also appear in tags
                   - Scoring: 0.3 points per significant word (max 4 words/1.2 points)
                
                3. Keyword Stuffing Detection (0.8 points)
                   - No stuffing detected: 0.8 points
                   - Stuffing detected (if any word appears >4 times OR any phrase repeats 3+ times OR 
                     unique word ratio <0.6): 0 points
                
                4. Structural Elements (0.8 points)
                   - 2-4 commas or pipe separators: 0.8 points
                   - 1 comma or pipe: 0.4 points
                   - 5+ commas/pipes or 0 separators: 0.2 points
                
                TAG OPTIMIZATION CRITERIA:
                1. Tag Count (1 point)
                   - Formula: (Number of tags / 13) × 1.0
                   - CRITICAL: Every tag MUST be 20 characters or less
                
                2. Multi-word Tag Ratio (1 point)
                   - Formula: (Number of multi-word tags / Total tags)
                
                3. Chain Structure (1 point)
                   - Definition: Tags where the last word of one tag matches the first word of the next tag
                   - Formula: (Number of chained tags / (Total tags - 1))
                
                4. Tag Diversity (1 point)
                   - Ratio of unique words to total words across all tags
                   - ≥0.8 ratio: 1.0 point
                   - 0.6-0.79 ratio: 0.75 points
                   - 0.4-0.59 ratio: 0.5 points
                   - <0.4 ratio: 0.25 points
                
                DESCRIPTION OPTIMIZATION CRITERIA:
                1. Length and Detail (1.2 points)
                   - 150-500 words: 1.2 points
                   - 100-149 words: 0.9 points
                   - 50-99 words: 0.6 points
                   - <50 or >500 words: 0.3 points
                
                2. Structural Formatting (1.2 points)
                   - 0.4 points each for:
                     - Paragraph breaks (>2 paragraphs with <300 characters each)
                     - List elements (contains •, *, -, or numbered lists)
                     - Formatting markers (contains **, _, #, or emojis as section dividers)
                
                3. Keyword Integration (1.6 points)
                   - Formula: (Number of title keywords in description / Total keywords in title) × 1.6
                
                Your response should be in JSON format with the following structure:
                {
                    "scores": {
                        "title_score": {
                            "value": 0.0, // From 0 to 4.0
                            "details": {
                                "character_count": {"score": 0.0, "max": 1.2, "passed": true/false},
                                "focus_keywords": {"score": 0.0, "max": 1.2, "passed": true/false, "keywords_found": ["word1", "word2"]},
                                "keyword_stuffing": {"score": 0.0, "max": 0.8, "passed": true/false, "stuffed_words": ["word1", "word2"]},
                                "structure": {"score": 0.0, "max": 0.8, "passed": true/false, "separator_count": 0}
                            }
                        },
                        "tags_score": {
                            "value": 0.0, // From 0 to 4.0
                            "details": {
                                "tag_count": {"score": 0.0, "max": 1.0, "passed": true/false, "count": 0},
                                "multi_word_tags": {"score": 0.0, "max": 1.0, "passed": true/false, "count": 0},
                                "chain_structure": {"score": 0.0, "max": 1.0, "passed": true/false, "count": 0},
                                "diversity": {"score": 0.0, "max": 1.0, "passed": true/false, "ratio": 0.0}
                            }
                        },
                        "description_score": {
                            "value": 0.0, // From 0 to 4.0
                            "details": {
                                "length": {"score": 0.0, "max": 1.2, "passed": true/false, "word_count": 0},
                                "formatting": {"score": 0.0, "max": 1.2, "passed": true/false, 
                                   "has_paragraphs": true/false, "has_lists": true/false, "has_formatting": true/false},
                                "keyword_integration": {"score": 0.0, "max": 1.6, "passed": true/false, "keywords_used": 0}
                            }
                        },
                        "overall_grade": {
                            "value": 0.0, // Weighted average: (Title×0.4) + (Tags×0.4) + (Description×0.2)
                            "letter": "A/B/C/D" // A: ≥3.5, B: ≥2.5, C: ≥1.5, D: <1.5
                        }
                    },
                    "improvements": {
                        "improved_title": "The optimized title",
                        "improved_tags": ["tag1", "tag2", "etc"],
                        "improved_description": "The optimized description",
                        "title_improvement_note": "Brief explanation of title improvements",
                        "tags_improvement_note": "Brief explanation of tag improvements",
                        "description_improvement_note": "Brief explanation of description improvements"
                    }
                }
                `;
                
                // Create the user message with the listing details
                const userMessage = field === 'title' ? 
                    `Please optimize only this Etsy listing title: "${title}"` :
                    field === 'tags' ? 
                    `Please optimize only these Etsy listing tags: ${tagsArray.length > 0 ? tagsArray.join(', ') : 'No tags provided'}` :
                    field === 'description' ? 
                    `Please optimize only this Etsy listing description: ${description || 'No description provided'}` :
                    `
                    Please optimize this Etsy listing:
                    
                    TITLE: ${title}
                    
                    TAGS: ${tagsArray.length > 0 ? tagsArray.join(', ') : 'No tags provided'}
                    
                    DESCRIPTION: ${description || 'No description provided'}
                    `;
                
                try {
                    console.log('Sending request to proxy server...');
                    console.log('System prompt length:', systemPrompt.length);
                    console.log('User message length:', userMessage.length);
                    console.log('Field to optimize:', field);
                    
                    // Test the API connectivity first
                    const testResponse = await fetch('/api/test', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ test: 'connection' })
                    });
                    
                    if (!testResponse.ok) {
                        throw new Error(`Test API request failed with status ${testResponse.status}`);
                    }
                    
                    console.log('Test API request successful, now calling main API...');
                    
                    // Use our local proxy server
                    const response = await fetch('/api/classify', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            systemPrompt,
                            userPrompt: userMessage,
                            field
                        })
                    });
                    
                    if (!response.ok) {
                        let errorMessage = 'API request failed with status ' + response.status;
                        try {
                            const errorData = await response.json();
                            errorMessage = errorData.error || errorMessage;
                        } catch (e) {
                            // If we can't parse the error as JSON, just use the status code message
                        }
                        throw new Error(errorMessage);
                    }
                    
                    const data = await response.json();
                    
                    // Parse the JSON response from the model
                    const contentText = data.content[0].text;
                    // Extract JSON from the response
                    const jsonMatch = contentText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        return JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('Could not parse optimization result');
                    }
                } catch (error) {
                    console.error('API Error:', error);
                    throw error;
                }
            }
            
            // Function to show field feedback
            function showFeedback(element, message, isSuccess = false) {
                element.textContent = message;
                element.classList.remove('hidden');
                
                if (isSuccess) {
                    element.classList.add('feedback-success');
                } else {
                    element.classList.remove('feedback-success');
                }
            }
            
            // Initialize field-specific buttons
            const titleOnlyBtn = document.getElementById('title-only-btn');
            const tagsOnlyBtn = document.getElementById('tags-only-btn');
            const descriptionOnlyBtn = document.getElementById('description-only-btn');
            const titleFeedback = document.getElementById('title-feedback');
            const tagsFeedback = document.getElementById('tags-feedback');
            const descriptionFeedback = document.getElementById('description-feedback');
            
            // Function to grade title based on the scoring framework
            function gradeTitle(title, tagsArray = []) {
                // Store the scoring results
                const results = {
                    character_count: { score: 0, max: 1.2, passed: false },
                    focus_keywords: { score: 0, max: 1.2, passed: false, keywords_found: [] },
                    keyword_stuffing: { score: 0, max: 0.8, passed: true, stuffed_words: [] },
                    structure: { score: 0, max: 0.8, passed: false, separator_count: 0 },
                    total_score: 0
                };
                
                // 1. Character Count (1.2 points)
                const charCount = title.length;
                if (charCount >= 100 && charCount <= 140) {
                    results.character_count.score = 1.2;
                    results.character_count.passed = true;
                } else if (charCount >= 80 && charCount <= 99) {
                    results.character_count.score = 0.9;
                    results.character_count.passed = true;
                } else if (charCount >= 141 && charCount <= 160) {
                    results.character_count.score = 0.6;
                    results.character_count.passed = false;
                } else {
                    results.character_count.score = 0.3;
                    results.character_count.passed = false;
                }
                
                // 2. Focus Keywords in First 40 Characters (1.2 points)
                // Definition: Number of significant words (>3 characters) that also appear in tags
                // Scoring: 0.3 points per significant word (max 4 words/1.2 points)
                
                // Get the first 40 characters of the title
                const first40Chars = title.substring(0, 40).toLowerCase();
                
                // Extract significant words from the first 40 chars
                const titleWords = first40Chars.split(/\s+|,|\|/).filter(word => 
                    word.length > 3 && !['with', 'that', 'this', 'from', 'your', 'and', 'for'].includes(word)
                );
                
                // Also extract multi-word combinations from first 40 chars
                const titlePhrases = [];
                
                // Get all words (including those under 3 chars) for phrase building
                const allFirstWords = first40Chars.split(/\s+|,|\|/).filter(w => w.length > 0);
                
                // Create 2-word phrases from adjacent words
                for (let i = 0; i < allFirstWords.length - 1; i++) {
                    titlePhrases.push(`${allFirstWords[i]} ${allFirstWords[i+1]}`);
                }
                
                // Create 3-word phrases if available
                for (let i = 0; i < allFirstWords.length - 2; i++) {
                    titlePhrases.push(`${allFirstWords[i]} ${allFirstWords[i+1]} ${allFirstWords[i+2]}`);
                }
                
                // Prepare for matching against tags
                let keywordMatches = 0;
                const matchedKeywords = [];
                
                // Only process if we have tags to compare against
                if (tagsArray.length > 0) {
                    // Convert tags to lowercase for matching
                    const lowercaseTags = tagsArray.map(tag => tag.toLowerCase());
                    
                    // First check for exact tag matches or contains relationships
                    for (const tag of lowercaseTags) {
                        // Check if this tag appears in the first 40 chars directly
                        if (first40Chars.includes(tag) && !matchedKeywords.includes(tag)) {
                            keywordMatches++;
                            matchedKeywords.push(tag);
                            
                            // Limit to 4 matches (max score)
                            if (keywordMatches >= 4) break;
                        }
                    }
                    
                    // Next check multi-word phrases if we still need matches
                    if (keywordMatches < 4) {
                        for (const phrase of titlePhrases) {
                            // Skip if we already matched this phrase
                            if (matchedKeywords.includes(phrase)) continue;
                            
                            // See if any tag contains this phrase or if this phrase contains a tag
                            for (const tag of lowercaseTags) {
                                if ((tag.includes(phrase) || phrase.includes(tag)) && 
                                    !matchedKeywords.includes(phrase)) {
                                    keywordMatches++;
                                    matchedKeywords.push(phrase);
                                    break;
                                }
                            }
                            
                            // Limit to 4 matches
                            if (keywordMatches >= 4) break;
                        }
                    }
                    
                    // Finally check individual words if we still need matches
                    if (keywordMatches < 4) {
                        for (const word of titleWords) {
                            // Skip words already included in matched phrases/tags
                            if (matchedKeywords.some(match => match.includes(word))) continue;
                            
                            // Check if any tag contains this word
                            for (const tag of lowercaseTags) {
                                if (tag.includes(word) && !matchedKeywords.includes(word)) {
                                    keywordMatches++;
                                    matchedKeywords.push(word);
                                    break;
                                }
                            }
                            
                            // Limit to 4 matches
                            if (keywordMatches >= 4) break;
                        }
                    }
                } else {
                    // If no tags provided, count significant words in first 40 chars
                    // (this gives benefit of doubt when only analyzing title)
                    keywordMatches = Math.min(titleWords.length, 4);
                    matchedKeywords.push(...titleWords.slice(0, 4));
                }
                
                // Store the matched keywords
                results.focus_keywords.keywords_found = matchedKeywords.slice(0, 4); // Limit to top 4
                
                // Score 0.3 points per keyword, max 1.2 (4 keywords)
                results.focus_keywords.score = Math.min(keywordMatches * 0.3, 1.2);
                results.focus_keywords.passed = keywordMatches > 0;
                
                // 3. Keyword Stuffing Detection (0.8 points)
                // Count word frequencies
                const words = title.toLowerCase().split(/\s+|,|\|/).filter(word => word.length > 3);
                const wordFrequency = {};
                words.forEach(word => {
                    wordFrequency[word] = (wordFrequency[word] || 0) + 1;
                });
                
                // Check for stuffed words (appearing more than 4 times)
                const stuffedWords = Object.keys(wordFrequency).filter(word => wordFrequency[word] > 4);
                
                // Check for repeated phrases
                const phrases = [];
                const titleParts = title.split(/,|\|/).map(part => part.trim());
                let repeatedPhrases = 0;
                titleParts.forEach(phrase => {
                    if (phrases.includes(phrase)) {
                        repeatedPhrases++;
                    }
                    phrases.push(phrase);
                });
                
                // Calculate unique word ratio
                const uniqueWordRatio = Object.keys(wordFrequency).length / words.length;
                
                // Set keyword stuffing score
                if (stuffedWords.length > 0 || repeatedPhrases >= 3 || uniqueWordRatio < 0.6) {
                    results.keyword_stuffing.score = 0;
                    results.keyword_stuffing.passed = false;
                    results.keyword_stuffing.stuffed_words = stuffedWords;
                } else {
                    results.keyword_stuffing.score = 0.8;
                    results.keyword_stuffing.passed = true;
                }
                
                // 4. Structural Elements (0.8 points)
                // Count commas and pipes
                const commaCount = (title.match(/,/g) || []).length;
                const pipeCount = (title.match(/\|/g) || []).length;
                const separatorCount = commaCount + pipeCount;
                results.structure.separator_count = separatorCount;
                
                if (separatorCount >= 2 && separatorCount <= 4) {
                    results.structure.score = 0.8;
                    results.structure.passed = true;
                } else if (separatorCount === 1) {
                    results.structure.score = 0.4;
                    results.structure.passed = false;
                } else {
                    results.structure.score = 0.2;
                    results.structure.passed = false;
                }
                
                // Calculate total score
                results.total_score = results.character_count.score + 
                                      results.focus_keywords.score + 
                                      results.keyword_stuffing.score + 
                                      results.structure.score;
                
                return results;
            }
            
            // Handle title-only optimization
            titleOnlyBtn.addEventListener('click', async function() {
                // Clear previous feedback
                titleFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Get values
                const title = titleField.value.trim();
                
                if (!title) {
                    showError('Please enter a product title');
                    return;
                }
                
                // Show loading indicator
                titleOnlyBtn.textContent = 'Optimizing...';
                titleOnlyBtn.disabled = true;
                
                try {
                    // Call API for title only
                    const result = await optimizeWithOpenAI(title, tags, '', 'title');
                    
                    // Show feedback
                    showFeedback(titleFeedback, result.improvements.title_improvement_note, true);
                    
                    // Update title with improved version
                    titleField.value = result.improvements.improved_title;
                    updateTitleCount();
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Reset button
                    titleOnlyBtn.textContent = 'Optimize Title Only';
                    titleOnlyBtn.disabled = false;
                }
            });
            
            // Function to grade tags based on the scoring framework
            function gradeTags(tagsArray) {
                // Store the scoring results
                const results = {
                    tag_count: { score: 0, max: 1.0, passed: false, count: tagsArray.length },
                    multi_word_tags: { score: 0, max: 1.0, passed: false, count: 0 },
                    chain_structure: { score: 0, max: 1.0, passed: false, count: 0 },
                    diversity: { score: 0, max: 1.0, passed: false, ratio: 0 },
                    total_score: 0
                };
                
                // 1. Tag Count (1 point) - (Number of tags / 13) × 1.0
                results.tag_count.score = Math.min((tagsArray.length / 13) * 1.0, 1.0);
                results.tag_count.passed = tagsArray.length >= 10; // Passing threshold (at least 10 tags)
                
                // 2. Multi-word Tag Ratio (1 point) - (Number of multi-word tags / Total tags)
                if (tagsArray.length > 0) {
                    const multiWordTags = tagsArray.filter(tag => tag.split(/\s+/).length > 1);
                    results.multi_word_tags.count = multiWordTags.length;
                    results.multi_word_tags.score = multiWordTags.length / tagsArray.length;
                    results.multi_word_tags.passed = results.multi_word_tags.score >= 0.7; // Passing threshold (at least 70% multi-word)
                }
                
                // 3. Chain Structure (1 point) - (Number of chained tags / (Total tags - 1))
                // Chained tags: Words from different tags appear in sequential order in the original title
                if (tagsArray.length > 1) {
                    // First, get the title to use for positional reference
                    // Assuming titleField is accessible from this function
                    const title = titleField.value.trim();
                    
                    // Create a map of words to their positions in the title
                    const wordPositions = new Map();
                    const titleWords = title.toLowerCase().split(/\s+|,|\|/).filter(w => w.length > 2);
                    
                    titleWords.forEach((word, index) => {
                        // Store each word with its position
                        if (!wordPositions.has(word)) {
                            wordPositions.set(word, []);
                        }
                        wordPositions.get(word).push(index);
                    });
                    
                    // Debug word positions
                    console.log('Word positions in title:', Object.fromEntries(wordPositions));
                    
                    // For each tag, find the positions of its words in the title
                    const tagWordPositions = [];
                    for (const tag of tagsArray) {
                        const words = tag.toLowerCase().split(/\s+/).filter(w => w.length > 2);
                        const positions = [];
                        
                        for (const word of words) {
                            if (wordPositions.has(word)) {
                                positions.push(...wordPositions.get(word));
                            }
                        }
                        
                        // Sort positions to maintain order
                        positions.sort((a, b) => a - b);
                        tagWordPositions.push({
                            tag: tag,
                            positions: positions
                        });
                    }
                    
                    // Debug tag positions
                    console.log('Tag word positions:', tagWordPositions);
                    
                    // Count chained tags - tags are chained if words appear in sequential order as in the title
                    // (not necessarily adjacent, just in the same order)
                    let chainedTags = 0;
                    const tagHasChain = new Array(tagsArray.length).fill(false);
                    const chainedPairs = []; // Store the actual pairs of chained tags
                    
                    for (let i = 0; i < tagWordPositions.length; i++) {
                        if (tagHasChain[i]) continue; // Skip if already counted
                        
                        const tag1 = tagWordPositions[i];
                        let foundChain = false;
                        
                        for (let j = 0; j < tagWordPositions.length; j++) {
                            if (i === j || tagHasChain[j]) continue;
                            
                            const tag2 = tagWordPositions[j];
                            
                            // Check for words appearing in sequential order in the title
                            for (const pos1 of tag1.positions) {
                                for (const pos2 of tag2.positions) {
                                    // Tags are chained if positions are in sequential order in the title
                                    if (pos1 < pos2) {
                                        console.log(`Chain found: "${tag1.tag}" and "${tag2.tag}" at positions ${pos1} and ${pos2} (sequential order)`);
                                        
                                        // Store the chain pair
                                        chainedPairs.push({
                                            tag1: tag1.tag,
                                            tag2: tag2.tag,
                                            pos1: pos1,
                                            pos2: pos2
                                        });
                                        
                                        tagHasChain[i] = true;
                                        tagHasChain[j] = true;
                                        chainedTags++;
                                        foundChain = true;
                                        break;
                                    }
                                }
                                if (foundChain) break;
                            }
                            if (foundChain) break;
                        }
                    }
                    
                    // Ensure we don't count more chains than possible
                    chainedTags = Math.min(chainedTags, Math.floor(tagsArray.length / 2));
                    
                    // For debugging
                    console.log('Chain analysis for tags:', tagsArray);
                    console.log('Chained tags found:', chainedTags);
                    console.log('Chained pairs:', chainedPairs);
                    
                    // Store the chained pairs in the results
                    results.chain_structure.count = chainedTags;
                    results.chain_structure.score = Math.min(chainedTags / (tagsArray.length - 1), 1.0);
                    results.chain_structure.passed = results.chain_structure.score >= 0.5; // Passing threshold (at least 50% chained)
                    results.chain_structure.chained_pairs = chainedPairs; // Store the actual chained pairs
                }
                
                // 4. Tag Diversity (1 point) - Ratio of unique words to total words across all tags
                if (tagsArray.length > 0) {
                    // Collect all words from all tags
                    const allWords = tagsArray.join(' ').toLowerCase().split(/\s+|,|\|/).filter(word => word.length > 2);
                    const uniqueWords = [...new Set(allWords)];
                    
                    results.diversity.ratio = uniqueWords.length / allWords.length;
                    
                    // Scoring based on ratio
                    if (results.diversity.ratio >= 0.8) {
                        results.diversity.score = 1.0;
                    } else if (results.diversity.ratio >= 0.6) {
                        results.diversity.score = 0.75;
                    } else if (results.diversity.ratio >= 0.4) {
                        results.diversity.score = 0.5;
                    } else {
                        results.diversity.score = 0.25;
                    }
                    
                    results.diversity.passed = results.diversity.ratio >= 0.6; // Passing threshold
                }
                
                // Calculate total score
                results.total_score = results.tag_count.score + 
                                      results.multi_word_tags.score + 
                                      results.chain_structure.score + 
                                      results.diversity.score;
                
                return results;
            }
            
            // Function to grade description based on the scoring framework
            function gradeDescription(description, title) {
                // Store the scoring results
                const results = {
                    length: { score: 0, max: 1.2, passed: false, word_count: 0 },
                    formatting: { 
                        score: 0, 
                        max: 1.2, 
                        passed: false, 
                        has_paragraphs: false,
                        has_lists: false,
                        has_formatting: false
                    },
                    keyword_integration: { score: 0, max: 1.6, passed: false, keywords_used: 0 },
                    total_score: 0
                };
                
                // Exit early if no description
                if (!description) {
                    return results;
                }
                
                // 1. Length and Detail (1.2 points)
                const wordCount = description.trim().split(/\s+/).length;
                results.length.word_count = wordCount;
                
                if (wordCount >= 150 && wordCount <= 500) {
                    results.length.score = 1.2;
                    results.length.passed = true;
                } else if (wordCount >= 100 && wordCount <= 149) {
                    results.length.score = 0.9;
                    results.length.passed = true;
                } else if (wordCount >= 50 && wordCount <= 99) {
                    results.length.score = 0.6;
                    results.length.passed = false;
                } else {
                    results.length.score = 0.3;
                    results.length.passed = false;
                }
                
                // 2. Structural Formatting (1.2 points) - 0.4 points each for paragraph breaks, list elements, formatting markers
                
                // Check for paragraph breaks
                const paragraphs = description.split(/\n\s*\n/);
                results.formatting.has_paragraphs = paragraphs.length > 2 && paragraphs.some(p => p.length < 300);
                
                // Check for list elements
                results.formatting.has_lists = /[•*\-]/.test(description) || /\d+\.\s/.test(description);
                
                // Check for formatting markers
                results.formatting.has_formatting = /[\*\_\#]/.test(description) || /[🔸📌✅⭐]/.test(description);
                
                // Calculate formatting score (0.4 points for each element)
                results.formatting.score = (results.formatting.has_paragraphs ? 0.4 : 0) +
                                           (results.formatting.has_lists ? 0.4 : 0) +
                                           (results.formatting.has_formatting ? 0.4 : 0);
                
                results.formatting.passed = results.formatting.score >= 0.8; // Passing threshold (at least 2 elements)
                
                // 3. Keyword Integration (1.6 points) - (Keywords from title in description / Total keywords in title) × 1.6
                if (title) {
                    // Extract significant words from title (> 3 chars, not common words)
                    const titleWords = title.toLowerCase().split(/\s+|,|\|/).filter(word => 
                        word.length > 3 && !['with', 'that', 'this', 'from', 'your', 'and', 'for'].includes(word)
                    );
                    
                    const uniqueTitleWords = [...new Set(titleWords)];
                    const descWords = description.toLowerCase().split(/\s+|,|\|/);
                    
                    // Count how many title keywords appear in description
                    let keywordsUsed = 0;
                    uniqueTitleWords.forEach(word => {
                        if (descWords.includes(word)) {
                            keywordsUsed++;
                        }
                    });
                    
                    results.keyword_integration.keywords_used = keywordsUsed;
                    
                    // Calculate score: (keywords used / total unique keywords) × 1.6
                    if (uniqueTitleWords.length > 0) {
                        results.keyword_integration.score = Math.min((keywordsUsed / uniqueTitleWords.length) * 1.6, 1.6);
                        results.keyword_integration.passed = keywordsUsed / uniqueTitleWords.length >= 0.5; // At least 50% of keywords used
                    }
                }
                
                // Calculate total score
                results.total_score = results.length.score + 
                                      results.formatting.score + 
                                      results.keyword_integration.score;
                
                return results;
            }
            
            // Function to calculate overall grade based on all scoring components
            function calculateOverallGrade(titleScore, tagsScore, descriptionScore) {
                // Overall score = (Title score × 0.40) + (Tag score × 0.40) + (Description score × 0.20)
                const weightedTitleScore = titleScore * 0.4;
                const weightedTagsScore = tagsScore * 0.4;
                const weightedDescScore = descriptionScore * 0.2;
                
                const overallScore = weightedTitleScore + weightedTagsScore + weightedDescScore;
                
                // Determine letter grade
                let letterGrade;
                if (overallScore >= 3.5) {
                    letterGrade = 'A';
                } else if (overallScore >= 2.5) {
                    letterGrade = 'B';
                } else if (overallScore >= 1.5) {
                    letterGrade = 'C';
                } else {
                    letterGrade = 'D';
                }
                
                return {
                    score: overallScore,
                    letter: letterGrade,
                    title_component: weightedTitleScore,
                    tags_component: weightedTagsScore,
                    description_component: weightedDescScore
                };
            }
            
            // Handle title grading
            const titleGradeBtn = document.getElementById('title-grade-btn');
            titleGradeBtn.addEventListener('click', function() {
                // Clear previous feedback
                titleFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Get values
                const title = titleField.value.trim();
                
                if (!title) {
                    showError('Please enter a product title');
                    return;
                }
                
                // Grade the title
                const gradeResult = gradeTitle(title, tags);
                
                // Create a formatted feedback message
                let scoreMessage = `
                    <strong>Title Score: ${gradeResult.total_score.toFixed(1)}/4.0</strong><br>
                    <ul>
                        <li>${gradeResult.character_count.passed ? '✓' : '✗'} Character Count: ${gradeResult.character_count.score.toFixed(1)}/${gradeResult.character_count.max.toFixed(1)} (${title.length} chars)</li>
                        <li>${gradeResult.focus_keywords.passed ? '✓' : '✗'} Focus Keywords: ${gradeResult.focus_keywords.score.toFixed(1)}/${gradeResult.focus_keywords.max.toFixed(1)}`;
                
                if (gradeResult.focus_keywords.keywords_found.length > 0) {
                    scoreMessage += ` (Found: ${gradeResult.focus_keywords.keywords_found.join(', ')})`;
                }
                
                scoreMessage += `</li>
                        <li>${gradeResult.keyword_stuffing.passed ? '✓' : '✗'} Keyword Stuffing: ${gradeResult.keyword_stuffing.score.toFixed(1)}/${gradeResult.keyword_stuffing.max.toFixed(1)}`;
                
                if (gradeResult.keyword_stuffing.stuffed_words.length > 0) {
                    scoreMessage += ` (Overused words: ${gradeResult.keyword_stuffing.stuffed_words.join(', ')})`;
                }
                
                scoreMessage += `</li>
                        <li>${gradeResult.structure.passed ? '✓' : '✗'} Structure: ${gradeResult.structure.score.toFixed(1)}/${gradeResult.structure.max.toFixed(1)} (${gradeResult.structure.separator_count} separators)</li>
                    </ul>
                    <p>Optimize your title by ${gradeResult.total_score < 3.5 ? 'improving its structure, focusing on keywords, and ensuring optimal length.' : 'maintaining its current high quality.'}</p>
                `;
                
                // Show feedback
                titleFeedback.innerHTML = scoreMessage;
                titleFeedback.classList.remove('hidden');
                // Grade color based on score (using the same colors as the overall score)
                const gradeClass = gradeResult.total_score >= 3.5 ? 'grade-a' : 
                                  gradeResult.total_score >= 2.5 ? 'grade-b' :
                                  gradeResult.total_score >= 1.5 ? 'grade-c' : 'grade-d';
                
                titleFeedback.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue(`--${gradeClass.replace('grade-', '')}-color`) || '';
            });
            
            // Handle tags-only optimization
            tagsOnlyBtn.addEventListener('click', async function() {
                // Clear previous feedback
                tagsFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Get values
                const title = titleField.value.trim();
                
                // Show loading indicator
                tagsOnlyBtn.textContent = 'Optimizing...';
                tagsOnlyBtn.disabled = true;
                
                try {
                    // Call API for tags only
                    const result = await optimizeWithOpenAI(title, tags, '', 'tags');
                    
                    // Show feedback
                    showFeedback(tagsFeedback, result.improvements.tags_improvement_note, true);
                    
                    // Validate improved tags from API
                    const improvedTags = result.improvements.improved_tags;
                    const longTags = improvedTags.filter(tag => tag.length > 20);
                    
                    if (longTags.length > 0) {
                        // If AI returned tags that are too long, show error
                        showError(`API returned tags that exceed 20 characters: ${longTags.join(', ')}`);
                        // Still show feedback but don't update tags
                        showFeedback(tagsFeedback, `${result.improvements.tags_improvement_note} (Some tags were too long and weren't applied)`, false);
                    } else {
                        // Update tags with improved version
                        tags = improvedTags;
                        renderTags();
                    }
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Reset button
                    tagsOnlyBtn.textContent = 'Optimize Tags Only';
                    tagsOnlyBtn.disabled = false;
                }
            });
            
            // Handle tags grading
            const tagsGradeBtn = document.getElementById('tags-grade-btn');
            tagsGradeBtn.addEventListener('click', function() {
                // Clear previous feedback
                tagsFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                if (tags.length === 0) {
                    showError('Please add at least one tag');
                    return;
                }
                
                // Grade the tags
                const gradeResult = gradeTags(tags);
                
                // Create a formatted feedback message
                let scoreMessage = `
                    <strong>Tags Score: ${gradeResult.total_score.toFixed(1)}/4.0</strong><br>
                    <ul>
                        <li>${gradeResult.tag_count.passed ? '✓' : '✗'} Tag Count: ${gradeResult.tag_count.score.toFixed(1)}/${gradeResult.tag_count.max.toFixed(1)} (${gradeResult.tag_count.count}/13 tags)</li>
                        <li>${gradeResult.multi_word_tags.passed ? '✓' : '✗'} Multi-word Tags: ${gradeResult.multi_word_tags.score.toFixed(1)}/${gradeResult.multi_word_tags.max.toFixed(1)} (${gradeResult.multi_word_tags.count} multi-word tags)</li>
                        <li>${gradeResult.chain_structure.passed ? '✓' : '✗'} Chain Structure: ${gradeResult.chain_structure.score.toFixed(1)}/${gradeResult.chain_structure.max.toFixed(1)} (${gradeResult.chain_structure.count} chained tags)</li>
                        <li>${gradeResult.diversity.passed ? '✓' : '✗'} Tag Diversity: ${gradeResult.diversity.score.toFixed(1)}/${gradeResult.diversity.max.toFixed(1)} (Unique word ratio: ${gradeResult.diversity.ratio.toFixed(2)})</li>
                    </ul>
                    <p>Optimize your tags by ${tags.length < 13 ? 'using all 13 available tag slots, ' : ''}${gradeResult.multi_word_tags.passed ? '' : 'using more multi-word tags, '}${gradeResult.chain_structure.passed ? '' : 'implementing a chain structure, '}and ${gradeResult.diversity.passed ? 'maintaining good' : 'improving'} keyword diversity.</p>
                `;
                
                // Show feedback
                tagsFeedback.innerHTML = scoreMessage;
                tagsFeedback.classList.remove('hidden');
                // Grade color based on score
                const gradeClass = gradeResult.total_score >= 3.5 ? 'grade-a' : 
                                  gradeResult.total_score >= 2.5 ? 'grade-b' :
                                  gradeResult.total_score >= 1.5 ? 'grade-c' : 'grade-d';
                
                tagsFeedback.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue(`--${gradeClass.replace('grade-', '')}-color`) || '';
            });
            
            // Handle description-only optimization
            descriptionOnlyBtn.addEventListener('click', async function() {
                // Clear previous feedback
                descriptionFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Get values
                const title = titleField.value.trim();
                const description = descriptionField.value.trim();
                
                // Show loading indicator
                descriptionOnlyBtn.textContent = 'Optimizing...';
                descriptionOnlyBtn.disabled = true;
                
                try {
                    // Call API for description only
                    const result = await optimizeWithOpenAI(title, tags, description, 'description');
                    
                    // Show feedback
                    showFeedback(descriptionFeedback, result.improvements.description_improvement_note, true);
                    
                    // Update description with improved version
                    descriptionField.value = result.improvements.improved_description;
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Reset button
                    descriptionOnlyBtn.textContent = 'Optimize Description Only';
                    descriptionOnlyBtn.disabled = false;
                }
            });
            
            // Handle description grading
            const descriptionGradeBtn = document.getElementById('description-grade-btn');
            descriptionGradeBtn.addEventListener('click', function() {
                // Clear previous feedback
                descriptionFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Get values
                const title = titleField.value.trim();
                const description = descriptionField.value.trim();
                
                if (!description) {
                    showError('Please enter a product description');
                    return;
                }
                
                // Grade the description
                const gradeResult = gradeDescription(description, title);
                
                // Create a formatted feedback message
                let scoreMessage = `
                    <strong>Description Score: ${gradeResult.total_score.toFixed(1)}/4.0</strong><br>
                    <ul>
                        <li>${gradeResult.length.passed ? '✓' : '✗'} Length: ${gradeResult.length.score.toFixed(1)}/${gradeResult.length.max.toFixed(1)} (${gradeResult.length.word_count} words)</li>
                        <li>${gradeResult.formatting.passed ? '✓' : '✗'} Formatting: ${gradeResult.formatting.score.toFixed(1)}/${gradeResult.formatting.max.toFixed(1)}
                            <ul>
                                <li>${gradeResult.formatting.has_paragraphs ? '✓' : '✗'} Paragraph breaks</li>
                                <li>${gradeResult.formatting.has_lists ? '✓' : '✗'} List elements</li>
                                <li>${gradeResult.formatting.has_formatting ? '✓' : '✗'} Formatting markers</li>
                            </ul>
                        </li>
                        <li>${gradeResult.keyword_integration.passed ? '✓' : '✗'} Keyword Integration: ${gradeResult.keyword_integration.score.toFixed(1)}/${gradeResult.keyword_integration.max.toFixed(1)} (${gradeResult.keyword_integration.keywords_used} keywords used)</li>
                    </ul>
                    <p>Optimize your description by ${gradeResult.length.passed ? '' : 'adjusting length (aim for 150-500 words), '}${gradeResult.formatting.passed ? '' : 'improving formatting with paragraphs, lists, and styling, '}and ${gradeResult.keyword_integration.passed ? 'maintaining good' : 'improving'} keyword integration from your title.</p>
                `;
                
                // Show feedback
                descriptionFeedback.innerHTML = scoreMessage;
                descriptionFeedback.classList.remove('hidden');
                // Grade color based on score
                const gradeClass = gradeResult.total_score >= 3.5 ? 'grade-a' : 
                                  gradeResult.total_score >= 2.5 ? 'grade-b' :
                                  gradeResult.total_score >= 1.5 ? 'grade-c' : 'grade-d';
                
                descriptionFeedback.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue(`--${gradeClass.replace('grade-', '')}-color`) || '';
            });
            
            // Handle "Grade All" button
            const gradeAllBtn = document.getElementById('grade-all-btn');
            gradeAllBtn.addEventListener('click', function() {
                // Clear previous feedback
                titleFeedback.classList.add('hidden');
                tagsFeedback.classList.add('hidden');
                descriptionFeedback.classList.add('hidden');
                errorDisplay.classList.add('hidden');
                
                // Get values
                const title = titleField.value.trim();
                const description = descriptionField.value.trim();
                
                // Validate inputs
                if (!title) {
                    showError('Please enter a product title');
                    return;
                }
                
                // Grade each component
                const titleResult = gradeTitle(title, tags);
                const tagsResult = gradeTags(tags);
                const descriptionResult = gradeDescription(description, title);
                
                // Calculate overall grade
                const overallGrade = calculateOverallGrade(
                    titleResult.total_score, 
                    tagsResult.total_score, 
                    descriptionResult.total_score
                );
                
                // Create an overall feedback message
                let overallMessage = `
                    <strong>Overall Listing Grade: ${overallGrade.letter} (${overallGrade.score.toFixed(2)}/4.0)</strong><br>
                    <ul>
                        <li>Title: ${titleResult.total_score.toFixed(1)}/4.0 
                           (contributes ${overallGrade.title_component.toFixed(2)} points, 40% weight)</li>
                        <li>Tags: ${tagsResult.total_score.toFixed(1)}/4.0
                           (contributes ${overallGrade.tags_component.toFixed(2)} points, 40% weight)</li>
                        <li>Description: ${descriptionResult.total_score.toFixed(1)}/4.0
                           (contributes ${overallGrade.description_component.toFixed(2)} points, 20% weight)</li>
                    </ul>
                    <p>To improve your overall listing grade, focus first on: 
                    ${titleResult.total_score < 3.0 ? 'optimizing your title' : 
                      tagsResult.total_score < 3.0 ? 'improving your tags' : 
                      descriptionResult.total_score < 3.0 ? 'enhancing your description' : 
                      'maintaining your high-quality listing'}.
                    </p>
                    <p>Click on the individual "Grade" buttons to see detailed feedback for each component.</p>
                `;
                
                // Show overall feedback
                showError(''); // Clear any previous errors
                const errorElement = document.getElementById('error-display');
                errorElement.innerHTML = overallMessage;
                errorElement.classList.remove('hidden');
                errorElement.classList.remove('error-message');
                errorElement.style.color = '#333';
                errorElement.style.fontWeight = 'normal';
                
                // Set the background color based on the overall grade
                const gradeClass = overallGrade.letter === 'A' ? 'a' : 
                                 overallGrade.letter === 'B' ? 'b' :
                                 overallGrade.letter === 'C' ? 'c' : 'd';
                
                errorElement.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue(`--${gradeClass}-color`) || '';
                errorElement.style.borderLeft = `4px solid var(--etsy-orange)`;
                errorElement.style.padding = '15px';
                
                // Also show individual grade feedback
                titleGradeBtn.click();
                if (tags.length > 0) tagsGradeBtn.click();
                if (description) descriptionGradeBtn.click();
                
                // Scroll to results
                errorElement.scrollIntoView({ behavior: 'smooth' });
            });
            
            // Handle form submission (optimize all)
            optimizerForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                // Clear previous errors and feedback
                errorDisplay.classList.add('hidden');
                errorDisplay.textContent = '';
                titleFeedback.classList.add('hidden');
                tagsFeedback.classList.add('hidden');
                descriptionFeedback.classList.add('hidden');
                
                // Get form values
                const title = titleField.value.trim();
                const description = descriptionField.value.trim();
                
                // Validate inputs
                if (!title) {
                    showError('Please enter a product title');
                    return;
                }
                
                // Show loading overlay
                document.querySelector('.loading').style.display = 'flex';
                
                try {
                    // Call OpenAI API for full optimization
                    const result = await optimizeWithOpenAI(title, tags, description, 'all');
                    
                    // Validate tags from API
                    const improvedTags = result.improvements.improved_tags;
                    const longTags = improvedTags.filter(tag => tag.length > 20);
                    
                    if (longTags.length > 0) {
                        // Show warning about tags but still display results
                        showError(`API returned tags that exceed 20 characters: ${longTags.join(', ')}. These tags won't be applied automatically.`);
                        // Update tag improvement note to indicate issue
                        result.improvements.tags_improvement_note += " (Warning: Some tags exceed 20 characters and need to be shortened)";
                    }
                    
                    // Update UI with results
                    updateResults(result, title, tags, description);
                    
                    // Show results section
                    resultsSection.classList.remove('hidden');
                    
                    // Smoothly scroll to results
                    resultsSection.scrollIntoView({ behavior: 'smooth' });
                    
                    // Show success feedback on all fields
                    showFeedback(titleFeedback, "Title optimized successfully!", true);
                    showFeedback(tagsFeedback, longTags.length > 0 ? 
                        "Tags generated but some exceed 20 characters" : 
                        "Tags optimized successfully!", longTags.length === 0);
                    showFeedback(descriptionFeedback, "Description optimized successfully!", true);
                } catch (error) {
                    showError('Error: ' + error.message);
                } finally {
                    // Hide loading overlay
                    document.querySelector('.loading').style.display = 'none';
                }
            });
            
            // Function to update UI with optimization results
            function updateResults(result, originalTitle, originalTags, originalDescription) {
                // Update score cards
                document.querySelector('.score.grade-b .score-value').textContent = 
                    result.scores.overall_grade.value.toFixed(1) + '/4.0';
                document.querySelector('.score.grade-b').className = 
                    'score grade-' + result.scores.overall_grade.letter.toLowerCase();
                
                // Update title score
                const titleScoreElement = document.querySelector('.score-card:nth-child(2) .score-value');
                titleScoreElement.textContent = result.scores.title_score.value.toFixed(1) + '/4.0';
                
                const titleDetails = document.querySelector('.score-card:nth-child(2) .score-details');
                
                // Get character count info
                const charCountInfo = result.scores.title_score.details.character_count;
                const focusKeywordsInfo = result.scores.title_score.details.focus_keywords;
                const keywordStuffingInfo = result.scores.title_score.details.keyword_stuffing;
                const structureInfo = result.scores.title_score.details.structure;
                
                // Build more detailed HTML with the additional data
                titleDetails.innerHTML = `
                    <div>${charCountInfo.passed ? '✓' : '✗'} Character Count: ${charCountInfo.score.toFixed(1)}/${charCountInfo.max.toFixed(1)}</div>
                    <div>${focusKeywordsInfo.passed ? '✓' : '✗'} Focus Keywords: ${focusKeywordsInfo.score.toFixed(1)}/${focusKeywordsInfo.max.toFixed(1)}
                        ${focusKeywordsInfo.keywords_found && focusKeywordsInfo.keywords_found.length > 0 ? 
                        `<span class="detail-info">(Found: ${focusKeywordsInfo.keywords_found.join(', ')})</span>` : ''}
                    </div>
                    <div>${keywordStuffingInfo.passed ? '✓' : '✗'} Keyword Stuffing: ${keywordStuffingInfo.score.toFixed(1)}/${keywordStuffingInfo.max.toFixed(1)}
                        ${keywordStuffingInfo.stuffed_words && keywordStuffingInfo.stuffed_words.length > 0 ? 
                        `<span class="detail-info">(Stuffed: ${keywordStuffingInfo.stuffed_words.join(', ')})</span>` : ''}
                    </div>
                    <div>${structureInfo.passed ? '✓' : '✗'} Structure: ${structureInfo.score.toFixed(1)}/${structureInfo.max.toFixed(1)}
                        ${structureInfo.separator_count !== undefined ? 
                        `<span class="detail-info">(Separators: ${structureInfo.separator_count})</span>` : ''}
                    </div>
                `;
                
                // Update tags score
                const tagsScoreElement = document.querySelector('.score-card:nth-child(3) .score-value');
                tagsScoreElement.textContent = result.scores.tags_score.value.toFixed(1) + '/4.0';
                
                const tagsDetails = document.querySelector('.score-card:nth-child(3) .score-details');
                
                // Get tag info
                const tagCountInfo = result.scores.tags_score.details.tag_count;
                const multiWordInfo = result.scores.tags_score.details.multi_word_tags;
                const chainInfo = result.scores.tags_score.details.chain_structure;
                const diversityInfo = result.scores.tags_score.details.diversity;
                
                tagsDetails.innerHTML = `
                    <div>${tagCountInfo.passed ? '✓' : '✗'} Tag Count: ${tagCountInfo.score.toFixed(1)}/${tagCountInfo.max.toFixed(1)}
                        ${tagCountInfo.count !== undefined ? 
                        `<span class="detail-info">(${tagCountInfo.count}/13 tags)</span>` : ''}
                    </div>
                    <div>${multiWordInfo.passed ? '✓' : '✗'} Multi-word Tags: ${multiWordInfo.score.toFixed(1)}/${multiWordInfo.max.toFixed(1)}
                        ${multiWordInfo.count !== undefined ? 
                        `<span class="detail-info">(${multiWordInfo.count} multi-word tags)</span>` : ''}
                    </div>
                    <div>${chainInfo.passed ? '✓' : '✗'} Chain Structure: ${chainInfo.score.toFixed(1)}/${chainInfo.max.toFixed(1)}
                        ${chainInfo.count !== undefined ? 
                        `<span class="detail-info">(${chainInfo.count} chained tags${chainInfo.chained_pairs && chainInfo.chained_pairs.length > 0 ? 
                            `: ${chainInfo.chained_pairs.map(pair => `"${pair.tag1}" → "${pair.tag2}"`).join(', ')}` : ''})</span>` : ''}
                    </div>
                    <div>${diversityInfo.passed ? '✓' : '✗'} Diversity: ${diversityInfo.score.toFixed(1)}/${diversityInfo.max.toFixed(1)}
                        ${diversityInfo.ratio !== undefined ? 
                        `<span class="detail-info">(Unique word ratio: ${diversityInfo.ratio.toFixed(2)})</span>` : ''}
                    </div>
                `;
                
                // Update description score
                const descScoreElement = document.querySelector('.score-card:nth-child(4) .score-value');
                descScoreElement.textContent = result.scores.description_score.value.toFixed(1) + '/4.0';
                
                const descDetails = document.querySelector('.score-card:nth-child(4) .score-details');
                
                // Get description info
                const lengthInfo = result.scores.description_score.details.length;
                const formattingInfo = result.scores.description_score.details.formatting;
                const keywordIntegrationInfo = result.scores.description_score.details.keyword_integration;
                
                // Check if we're using the old format with call_to_action or the new format
                const hasOldFormat = result.scores.description_score.details.call_to_action !== undefined;
                
                descDetails.innerHTML = `
                    <div>${lengthInfo.passed ? '✓' : '✗'} Length: ${lengthInfo.score.toFixed(1)}/${lengthInfo.max.toFixed(1)}
                        ${lengthInfo.word_count !== undefined ? 
                        `<span class="detail-info">(${lengthInfo.word_count} words)</span>` : ''}
                    </div>
                    <div>${formattingInfo.passed ? '✓' : '✗'} Formatting: ${formattingInfo.score.toFixed(1)}/${formattingInfo.max.toFixed(1)}
                        ${formattingInfo.has_paragraphs !== undefined ? 
                        `<span class="detail-info">(${formattingInfo.has_paragraphs ? '✓' : '✗'} Paragraphs, 
                         ${formattingInfo.has_lists ? '✓' : '✗'} Lists, 
                         ${formattingInfo.has_formatting ? '✓' : '✗'} Formatting)</span>` : ''}
                    </div>
                    <div>${keywordIntegrationInfo.passed ? '✓' : '✗'} Keyword Integration: ${keywordIntegrationInfo.score.toFixed(1)}/${keywordIntegrationInfo.max.toFixed(1)}
                        ${keywordIntegrationInfo.keywords_used !== undefined ? 
                        `<span class="detail-info">(${keywordIntegrationInfo.keywords_used} keywords used)</span>` : ''}
                    </div>
                    ${hasOldFormat ? 
                    `<div>${result.scores.description_score.details.call_to_action.passed ? '✓' : '✗'} Call to Action: ${result.scores.description_score.details.call_to_action.score.toFixed(1)}/${result.scores.description_score.details.call_to_action.max.toFixed(1)}</div>` : ''}
                `;
                
                // Update original and improved content
                document.getElementById('original-title').textContent = originalTitle;
                document.getElementById('improved-title').textContent = result.improvements.improved_title;
                document.getElementById('original-tags').textContent = originalTags.length > 0 ? originalTags.join(', ') : 'No tags provided';
                document.getElementById('improved-tags').textContent = result.improvements.improved_tags.join(', ');
                document.getElementById('original-description').textContent = originalDescription || 'No description provided';
                document.getElementById('improved-description').textContent = result.improvements.improved_description;
                
                // Update improvement notes
                document.querySelector('.improvement-note:nth-of-type(1)').textContent = result.improvements.title_improvement_note;
                document.querySelector('.improvement-note:nth-of-type(2)').textContent = result.improvements.tags_improvement_note;
                document.querySelector('.improvement-note:nth-of-type(3)').textContent = result.improvements.description_improvement_note;
            }
            
            // Tabs functionality
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs
                    tabs.forEach(t => t.classList.remove('active'));
                    // Add active class to clicked tab
                    this.classList.add('active');
                    
                    // Hide all tab contents
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // Show selected tab content
                    const tabId = this.dataset.tab + '-tab';
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // "Use improved" functionality
            document.getElementById('use-title').addEventListener('click', function() {
                titleField.value = document.getElementById('improved-title').textContent;
                updateTitleCount();
            });
            
            document.getElementById('use-tags').addEventListener('click', function() {
                const improvedTags = document.getElementById('improved-tags').textContent.split(', ');
                
                // Validate tag length
                const longTags = improvedTags.filter(tag => tag.length > 20);
                if (longTags.length > 0) {
                    showError(`Cannot use these tags: some exceed 20 characters: ${longTags.join(', ')}`);
                    return;
                }
                
                tags = improvedTags;
                renderTags();
                showFeedback(tagsFeedback, "Tags applied successfully!", true);
            });
            
            document.getElementById('use-description').addEventListener('click', function() {
                document.getElementById('description').value = document.getElementById('improved-description').textContent;
            });
            
            document.getElementById('save-all').addEventListener('click', function() {
                document.getElementById('use-title').click();
                document.getElementById('use-tags').click();
                document.getElementById('use-description').click();
                
                alert('All improvements have been applied to your listing!');
            });
        });
    </script>
</body>
</html>
